{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The project \"Dengue Dashboard\" is originally a part of the Bachelor Report of Jennifer Horstmann submitted to the faculty of Mathematics and Computer Science at the University of Bremen for the degree of Bachelor of Science. The system allows for management and visualizations of all relevant vital data for dengue fever patients as well as other parameters like the fuid balance. It is a web app that allows multiple clients to retrieve updates and notifications in real-time and therefore supports tele-consultation and timely interventions which are crucial in the treatment of dengue fever.","title":"Home"},{"location":"#_1","text":"The project \"Dengue Dashboard\" is originally a part of the Bachelor Report of Jennifer Horstmann submitted to the faculty of Mathematics and Computer Science at the University of Bremen for the degree of Bachelor of Science. The system allows for management and visualizations of all relevant vital data for dengue fever patients as well as other parameters like the fuid balance. It is a web app that allows multiple clients to retrieve updates and notifications in real-time and therefore supports tele-consultation and timely interventions which are crucial in the treatment of dengue fever.","title":""},{"location":"00_tut_actions/","text":"Work with new data from the back end Attention More content coming soon.","title":"Work with new data from the back end"},{"location":"00_tut_actions/#work-with-new-data-from-the-back-end","text":"Attention More content coming soon.","title":"Work with new data from the back end"},{"location":"00_tut_api/","text":"New REST API Endpoint In this tutorial we create a new REST API endpoint. Model First we have to create a model. In this example a simple patient model. from django.db import models class Patient ( models . Model ): \"\"\" Patient instance. \"\"\" first_name = models . CharField ( max_length = 240 ) last_name = models . CharField ( max_length = 240 ) admission_date = models . DateTimeField () dismissal_date = models . DateTimeField ( blank = True , null = True ) created_at = models . DateTimeField ( auto_now_add = True ) updated_at = models . DateTimeField ( auto_now = True ) file: dashboard/patients/models.py Serializer The second step is to serialize the model. To do so, we import the serializer from the Django Rest Framework and create a new Serializer Class, that inherits from the ModelSerializer. The base model for this serializer is the just created patient model. In the fields argument we may list all the fields we want to serialize. It is also possible to define __all__ or exclude certain fields. from rest_framework import serializers from dashboard.patients.models import Patient class PatientSerializer ( serializers . ModelSerializer ): class Meta : model = Patient fields = [ \"id\" , \"first_name\" , \"last_name\" , \"admission_date\" , \"dismissal_date\" , \"updated_at\" , \"created_at\" ] file: dashboard/patients/api/serializers.py View To be able to see the serialized data, search through it and refer to the endpoint via a link, a view needs to be set up. A fairly minimalistic setup looks something like this. The ModelViewSet is imported from the Django Rest Framework and the Base for the ViewSet. The serializer is the one we just created and the queryset may be more simple but in this way shows the possibility to create more custom functions to define the queryset. An alternative to the queryset definition below would be to write queryset = Patient.objects.all().order_by('-admission_date') right beneath the serializer_class and leaving out the method get_queryset . from rest_framework.viewsets import ModelViewSet from dashboard.patients.api.serializers import PatientSerializer from dashboard.patients.models import Patient class PatientViewSet ( ModelViewSet ): \"\"\" This view returns a list of all patients in the systems ordered by their admission date. \"\"\" serializer_class = PatientSerializer def get_queryset ( self ): queryset = Patient . objects . all () queryset = queryset . order_by ( '-admission_date' ) return queryset file: dashboard/patients/api/views.py Info If you take a look at the Definition of ModelViewSet : class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet): \"\"\" A viewset that provides default `create()`, `retrieve()`, `update()`, `partial_update()`, `destroy()` and `list()` actions. \"\"\" You can see, that it provides create, retrieve, update, delete and list functions, just as you would expect a REST API to. If you prefer a more specific definition, e.g. an endpoint with just the list action, you may wanna consider to only use the ListModelMixin instead of the ModelViewSet . URLs Finally, we have to define a route for the api. The string we define here will be the string that follows the /api/ . So in this case, our new route, that is connected to the PatientViewSet that we created in the previous step is www.example.com/api/patients/ from django.urls import path , include from rest_framework.routers import DefaultRouter from dashboard.patients.api.views import PatientViewSet router = DefaultRouter () router . register ( r \"patients\" , PatientViewSet , basename = \"patients\" ) urlpatterns = [ path ( \"\" , include ( router . urls )), ] file: dashboard/patients/api/urls.py Results Browsable API /api/patients/ At the /api endpoint you can find the Browsable API with all exposed endpoints. The data of our newly created endpoint can be seen at /api/patients/ and will show a list of all the instances of a patient model with all the fields defined in the serializer. Swagger API Documentation /swagger The Swagger API Documentation also shows all the currently available endpoints, but focuses more on the specification of the endpoints rather than on the data itself. However, the saved instances of a model can be obtained through the interactive mode of swagger, where you can request data from any endpoint or even post data to an endpoint.","title":"New REST API Endpoint"},{"location":"00_tut_api/#new-rest-api-endpoint","text":"In this tutorial we create a new REST API endpoint.","title":"New REST API Endpoint"},{"location":"00_tut_api/#model","text":"First we have to create a model. In this example a simple patient model. from django.db import models class Patient ( models . Model ): \"\"\" Patient instance. \"\"\" first_name = models . CharField ( max_length = 240 ) last_name = models . CharField ( max_length = 240 ) admission_date = models . DateTimeField () dismissal_date = models . DateTimeField ( blank = True , null = True ) created_at = models . DateTimeField ( auto_now_add = True ) updated_at = models . DateTimeField ( auto_now = True ) file: dashboard/patients/models.py","title":"Model"},{"location":"00_tut_api/#serializer","text":"The second step is to serialize the model. To do so, we import the serializer from the Django Rest Framework and create a new Serializer Class, that inherits from the ModelSerializer. The base model for this serializer is the just created patient model. In the fields argument we may list all the fields we want to serialize. It is also possible to define __all__ or exclude certain fields. from rest_framework import serializers from dashboard.patients.models import Patient class PatientSerializer ( serializers . ModelSerializer ): class Meta : model = Patient fields = [ \"id\" , \"first_name\" , \"last_name\" , \"admission_date\" , \"dismissal_date\" , \"updated_at\" , \"created_at\" ] file: dashboard/patients/api/serializers.py","title":"Serializer"},{"location":"00_tut_api/#view","text":"To be able to see the serialized data, search through it and refer to the endpoint via a link, a view needs to be set up. A fairly minimalistic setup looks something like this. The ModelViewSet is imported from the Django Rest Framework and the Base for the ViewSet. The serializer is the one we just created and the queryset may be more simple but in this way shows the possibility to create more custom functions to define the queryset. An alternative to the queryset definition below would be to write queryset = Patient.objects.all().order_by('-admission_date') right beneath the serializer_class and leaving out the method get_queryset . from rest_framework.viewsets import ModelViewSet from dashboard.patients.api.serializers import PatientSerializer from dashboard.patients.models import Patient class PatientViewSet ( ModelViewSet ): \"\"\" This view returns a list of all patients in the systems ordered by their admission date. \"\"\" serializer_class = PatientSerializer def get_queryset ( self ): queryset = Patient . objects . all () queryset = queryset . order_by ( '-admission_date' ) return queryset file: dashboard/patients/api/views.py Info If you take a look at the Definition of ModelViewSet : class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet): \"\"\" A viewset that provides default `create()`, `retrieve()`, `update()`, `partial_update()`, `destroy()` and `list()` actions. \"\"\" You can see, that it provides create, retrieve, update, delete and list functions, just as you would expect a REST API to. If you prefer a more specific definition, e.g. an endpoint with just the list action, you may wanna consider to only use the ListModelMixin instead of the ModelViewSet .","title":"View"},{"location":"00_tut_api/#urls","text":"Finally, we have to define a route for the api. The string we define here will be the string that follows the /api/ . So in this case, our new route, that is connected to the PatientViewSet that we created in the previous step is www.example.com/api/patients/ from django.urls import path , include from rest_framework.routers import DefaultRouter from dashboard.patients.api.views import PatientViewSet router = DefaultRouter () router . register ( r \"patients\" , PatientViewSet , basename = \"patients\" ) urlpatterns = [ path ( \"\" , include ( router . urls )), ] file: dashboard/patients/api/urls.py","title":"URLs"},{"location":"00_tut_api/#results","text":"","title":"Results"},{"location":"00_tut_api/#browsable-api","text":"/api/patients/ At the /api endpoint you can find the Browsable API with all exposed endpoints. The data of our newly created endpoint can be seen at /api/patients/ and will show a list of all the instances of a patient model with all the fields defined in the serializer.","title":"Browsable API"},{"location":"00_tut_api/#swagger-api-documentation","text":"/swagger The Swagger API Documentation also shows all the currently available endpoints, but focuses more on the specification of the endpoints rather than on the data itself. However, the saved instances of a model can be obtained through the interactive mode of swagger, where you can request data from any endpoint or even post data to an endpoint.","title":"Swagger API Documentation"},{"location":"00_tut_create/","text":"Create a new report via WebSocket In this tutorial we are going to create a report using WebSockets. Prerequisites Established WebSocket connection State-management is set-up Retrieve a list of reports To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. create a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports , together with a JSON Object that contains the data for the report as parameters to the create method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: createReport ( context , payload ) { let client = context . rootState . socket . client ; context . dispatch ( 'formatJson' , payload ). then (( jsonObj ) => { client . create ( \"reports\" , jsonObj ). then (( report ) => { context . commit ( \"UPDATE_REPORT_DATA\" , [ report ]); }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }); }, client is a variable containing the established WebSocket connection. The create method returns a response or an error, which may be handled as needed. In this case, the response triggers a mutation that alters the state containing the current report data. In case of an error, the error triggers a mutation that updates the global notifications. Info The context.dispatch('formatJson', payload) part in the listing above will call a function that formats the parameter called payload that is given to the createReport function into a JSON Object. It then returns this Object. The response is then passed into the next function that is client.create(\"reports\", jsonObj) . You may also just pass a JSON Object as a payload and leave the formatJson out.","title":"Create a new report"},{"location":"00_tut_create/#create-a-new-report-via-websocket","text":"In this tutorial we are going to create a report using WebSockets.","title":"Create a new report via WebSocket"},{"location":"00_tut_create/#prerequisites","text":"Established WebSocket connection State-management is set-up","title":"Prerequisites"},{"location":"00_tut_create/#retrieve-a-list-of-reports","text":"To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. create a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports , together with a JSON Object that contains the data for the report as parameters to the create method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: createReport ( context , payload ) { let client = context . rootState . socket . client ; context . dispatch ( 'formatJson' , payload ). then (( jsonObj ) => { client . create ( \"reports\" , jsonObj ). then (( report ) => { context . commit ( \"UPDATE_REPORT_DATA\" , [ report ]); }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }); }, client is a variable containing the established WebSocket connection. The create method returns a response or an error, which may be handled as needed. In this case, the response triggers a mutation that alters the state containing the current report data. In case of an error, the error triggers a mutation that updates the global notifications. Info The context.dispatch('formatJson', payload) part in the listing above will call a function that formats the parameter called payload that is given to the createReport function into a JSON Object. It then returns this Object. The response is then passed into the next function that is client.create(\"reports\", jsonObj) . You may also just pass a JSON Object as a payload and leave the formatJson out.","title":"Retrieve a list of reports"},{"location":"00_tut_delete/","text":"Delete a report via WebSocket In this tutorial we are going to delete a report using WebSockets. To do this we have to delete the specific history instance. Prerequisites Established WebSocket connection State-management is set-up Delete a report To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. delete a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports , together with a JSON Object that contains the data for the report as parameters to the delete method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: deleteReport ( context , payload ) { let client = context . rootState . socket . client ; client . delete ( \"history\" , payload . id ). then (() => { }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }); },","title":"Delete a report"},{"location":"00_tut_delete/#delete-a-report-via-websocket","text":"In this tutorial we are going to delete a report using WebSockets. To do this we have to delete the specific history instance.","title":"Delete a report via WebSocket"},{"location":"00_tut_delete/#prerequisites","text":"Established WebSocket connection State-management is set-up","title":"Prerequisites"},{"location":"00_tut_delete/#delete-a-report","text":"To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. delete a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports , together with a JSON Object that contains the data for the report as parameters to the delete method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: deleteReport ( context , payload ) { let client = context . rootState . socket . client ; client . delete ( \"history\" , payload . id ). then (() => { }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }); },","title":"Delete a report"},{"location":"00_tut_page/","text":"Create a new page In this tutorial we are going to create a new page inside the Web App. Create a component First of all we start by creating a new Component that we wish to display when navigating to our new page. We do so by creating a new file called NewPageComponent.vue . For the simplicity of this tutorial, the only contents of the page should be a headline, welcoming us, and a little lorem ipsum text. We add this to the component as follows: < template > < h1 > Hey, nice to have you on this page! </ h1 > < p > Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. </ p > </ template > < script > export default { name : \"NewPageComponent\" } </ script > < style scoped > </ style > Create a route Now that we have a component we want to display as a new page, we can define the name of the page and the URL-slug that the page is connected to. To do so we have to find the router.js file in vue_frontend/src/dashboard/entry/ and add a route at the end of the list of routes: ... { path : \"/patients/:id\" , name : \"patient report\" , props : true , component : () => import ( /* webpackChunkName: \"chunk-patients\" */ \"../views/SinglePatient.vue\" ), }, { path : \"/mynewpage\" , name : \"new page component\" , component : () => import ( /* webpackChunkName: \"chunk-newpage\" */ \"../views/NewPageComponent.vue\" ), // the source depends on the source of your file! }, ... This change might lead to errors in the Hot Refresh mechanisms, so that it is useful to restart the system. Then you should be able to navigate to localhost:8000/mynewpage . After these changes you can use the relative path /mynewpage inside the navigation, sidebar or in links to refer to this newly created page.","title":"New Page"},{"location":"00_tut_page/#create-a-new-page","text":"In this tutorial we are going to create a new page inside the Web App.","title":"Create a new page"},{"location":"00_tut_page/#create-a-component","text":"First of all we start by creating a new Component that we wish to display when navigating to our new page. We do so by creating a new file called NewPageComponent.vue . For the simplicity of this tutorial, the only contents of the page should be a headline, welcoming us, and a little lorem ipsum text. We add this to the component as follows: < template > < h1 > Hey, nice to have you on this page! </ h1 > < p > Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. </ p > </ template > < script > export default { name : \"NewPageComponent\" } </ script > < style scoped > </ style >","title":"Create a component"},{"location":"00_tut_page/#create-a-route","text":"Now that we have a component we want to display as a new page, we can define the name of the page and the URL-slug that the page is connected to. To do so we have to find the router.js file in vue_frontend/src/dashboard/entry/ and add a route at the end of the list of routes: ... { path : \"/patients/:id\" , name : \"patient report\" , props : true , component : () => import ( /* webpackChunkName: \"chunk-patients\" */ \"../views/SinglePatient.vue\" ), }, { path : \"/mynewpage\" , name : \"new page component\" , component : () => import ( /* webpackChunkName: \"chunk-newpage\" */ \"../views/NewPageComponent.vue\" ), // the source depends on the source of your file! }, ... This change might lead to errors in the Hot Refresh mechanisms, so that it is useful to restart the system. Then you should be able to navigate to localhost:8000/mynewpage . After these changes you can use the relative path /mynewpage inside the navigation, sidebar or in links to refer to this newly created page.","title":"Create a route"},{"location":"00_tut_retrieve/","text":"Retrieving Report data from the back end via WebSocket In this tutorial we are going to retrieve a list of reports from the back end using WebSocket. Prerequisites Established WebSocket connection State-management is set-up Retrieve a list of reports To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. retrieve a list of reports. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports as a parameter to the list method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: //load all reports loadReports ( context ) { let client = context . rootState . socket . client ; client . list ( \"reports\" ). then (( response ) => { context . commit ( \"UPDATE_REPORT_DATA\" , response ); }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }, client is a variable containing the established WebSocket connection. The list method returns a response or an error, which may be handled as needed. In this case, the response triggers a mutation that alters the state containing the current report data. In case of an error, the error triggers a mutation that updates the global notifications.","title":"Retrieve a list of reports"},{"location":"00_tut_retrieve/#retrieving-report-data-from-the-back-end-via-websocket","text":"In this tutorial we are going to retrieve a list of reports from the back end using WebSocket.","title":"Retrieving Report data from the back end via WebSocket"},{"location":"00_tut_retrieve/#prerequisites","text":"Established WebSocket connection State-management is set-up","title":"Prerequisites"},{"location":"00_tut_retrieve/#retrieve-a-list-of-reports","text":"To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. retrieve a list of reports. All we have to do is to connect to the WebSocket and pass the endpoint, in this case reports as a parameter to the list method. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: //load all reports loadReports ( context ) { let client = context . rootState . socket . client ; client . list ( \"reports\" ). then (( response ) => { context . commit ( \"UPDATE_REPORT_DATA\" , response ); }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }, client is a variable containing the established WebSocket connection. The list method returns a response or an error, which may be handled as needed. In this case, the response triggers a mutation that alters the state containing the current report data. In case of an error, the error triggers a mutation that updates the global notifications.","title":"Retrieve a list of reports"},{"location":"00_tut_update/","text":"Update report via WebSocket In this tutorial we are going to update a report using WebSockets. For this matter the specific history entry has to be updated. Prerequisites Established WebSocket connection State-management is set-up Update a report To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. patch a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case history , together with a JSON Object that contains the data for the report as parameters to the patch method. In addition to that, a primary key is needed to identify the right report. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: editReport ( context , payload ) { let client = context . rootState . socket . client ; context . dispatch ( 'formatJson' , payload ). then (( jsonObj ) => { client . patch ( \"history\" , payload . id , jsonObj ). then (() => { }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }); }, client is a variable containing the established WebSocket connection. The patch method returns a response or an error, which may be handled as needed. In case of an error, the error triggers a mutation that updates the global notifications. Info The context.dispatch('formatJson', payload) part in the listing above will call a function that formats the parameter called payload that is given to the createReport function into a JSON Object. It then returns this Object. The response is then passed into the next function that is client.patch(\"history\", payload.id, jsonObj) . You may also just pass a JSON Object as a payload and leave the formatJson out.","title":"Update a report"},{"location":"00_tut_update/#update-report-via-websocket","text":"In this tutorial we are going to update a report using WebSockets. For this matter the specific history entry has to be updated.","title":"Update report via WebSocket"},{"location":"00_tut_update/#prerequisites","text":"Established WebSocket connection State-management is set-up","title":"Prerequisites"},{"location":"00_tut_update/#update-a-report","text":"To interact with the data the WebSocket endpoints provide, the dcrf-client is used. It provides methods to e.g. patch a report. All we have to do is to connect to the WebSocket and pass the endpoint, in this case history , together with a JSON Object that contains the data for the report as parameters to the patch method. In addition to that, a primary key is needed to identify the right report. For an overview of available methods refer to the repository or the source code directly: https://github.com/theY4Kman/dcrf-client In the actions of a store module of the application, we will have the following code: editReport ( context , payload ) { let client = context . rootState . socket . client ; context . dispatch ( 'formatJson' , payload ). then (( jsonObj ) => { client . patch ( \"history\" , payload . id , jsonObj ). then (() => { }). catch (( e ) => { context . commit ( 'NEW_NOTIFICATION' , e . errors , { root : true }); }) ; }); }, client is a variable containing the established WebSocket connection. The patch method returns a response or an error, which may be handled as needed. In case of an error, the error triggers a mutation that updates the global notifications. Info The context.dispatch('formatJson', payload) part in the listing above will call a function that formats the parameter called payload that is given to the createReport function into a JSON Object. It then returns this Object. The response is then passed into the next function that is client.patch(\"history\", payload.id, jsonObj) . You may also just pass a JSON Object as a payload and leave the formatJson out.","title":"Update a report"},{"location":"00_tut_ws/","text":"New WebSocket Endpoint In this tutorial we create a new websocket endpoint. Model First we have to create a model. In this example a simple patient model. from django.db import models class Patient ( models . Model ): \"\"\" Patient instance. \"\"\" first_name = models . CharField ( max_length = 240 ) last_name = models . CharField ( max_length = 240 ) admission_date = models . DateTimeField () dismissal_date = models . DateTimeField ( blank = True , null = True ) created_at = models . DateTimeField ( auto_now_add = True ) updated_at = models . DateTimeField ( auto_now = True ) file: dashboard/patients/models.py Serializer The second step is to serialize the model. To do so, we import the serializer from the Django Rest Framework and create a new Serializer Class, that inherits from the ModelSerializer. The base model for this serializer is the just created patient model. In the fields argument we may list all the fields we want to serialize. It is also possible to define __all__ or exclude certain fields. from rest_framework import serializers from dashboard.patients.models import Patient class PatientSerializer ( serializers . ModelSerializer ): class Meta : model = Patient fields = [ \"id\" , \"first_name\" , \"last_name\" , \"admission_date\" , \"dismissal_date\" , \"updated_at\" , \"created_at\" ] file: dashboard/patients/api/serializers.py Consumer To be able to make the serialized data available to connected clients, a consumer needs to be set up. Clients that are connected to the WebSocket are called consumers . A fairly minimalistic setup looks something like this. Notice that a couple of Mixins are imported from the Django Channels Rest Framework , which provide the basic functionality. The serializer is the one we just created and the queryset is the one from the model above. To allow only authenticated users to connect, the permission_classes are set to \u00ecsAuthenticated . from djangochannelsrestframework import permissions from djangochannelsrestframework.generics import GenericAsyncAPIConsumer from djangochannelsrestframework.mixins import ( ListModelMixin , RetrieveModelMixin , UpdateModelMixin , PatchModelMixin , DeleteModelMixin , CreateModelMixin , ) from dashboard.patients.api.serializers import PatientSerializer from dashboard.patients.models import Patient class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,) file: dashboard/patients/consumers.py Info The Mixins that the consumer inherits from, are the actions that the WebSocket will provide. In the listing above you can e.g. see a ListModelMixin which will provide the list action for the consumer. URLs Finally, we have to define a route for the WebSocket, just like with the REST API. The routes for the WebSockets are called streams and are defined in asgi.py . In this file you will find the ProtocolTypeRouter , that routes HTTP and WebSocket requests accordingly. Here, the starting point for the WebSocket is defined as /ws , whereas we defined the starting point for REST API endpoints as /api (not here). The stream we define here will be the string that follows the /ws/ . So in this case, our new route, that is connected to the PatientConsumer that we created in the previous step will be called patients . Notice, that within this definition, the patients is not declared with quotation marks. However, the resulting route/URL is www.example.com/ws/patients/ . But with an important change to the REST API endpoints, because instead of: http:// www.example.com/api/patients/ or https:// www.example.com/api/patients/ we now have a change in protocols and must use: ws:// ww.example.com/ws/patients/ or wss:// ww.example.com/ws/patients/ from channels.routing import ProtocolTypeRouter , URLRouter from django.core.asgi import get_asgi_application from django.urls import re_path from dashboard.patients.consumers import PatientConsumer from channelsmultiplexer import AsyncJsonWebsocketDemultiplexer from config.middleware import TokenAuthMiddlewareStack application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : TokenAuthMiddlewareStack ( URLRouter ( [ re_path ( r \"^ws/$\" , AsyncJsonWebsocketDemultiplexer ( patients = PatientConsumer () . as_asgi (), ) . as_asgi ()), ] ) ), }) file: config/asgi.py","title":"New WebSocket Endpoint"},{"location":"00_tut_ws/#new-websocket-endpoint","text":"In this tutorial we create a new websocket endpoint.","title":"New WebSocket Endpoint"},{"location":"00_tut_ws/#model","text":"First we have to create a model. In this example a simple patient model. from django.db import models class Patient ( models . Model ): \"\"\" Patient instance. \"\"\" first_name = models . CharField ( max_length = 240 ) last_name = models . CharField ( max_length = 240 ) admission_date = models . DateTimeField () dismissal_date = models . DateTimeField ( blank = True , null = True ) created_at = models . DateTimeField ( auto_now_add = True ) updated_at = models . DateTimeField ( auto_now = True ) file: dashboard/patients/models.py","title":"Model"},{"location":"00_tut_ws/#serializer","text":"The second step is to serialize the model. To do so, we import the serializer from the Django Rest Framework and create a new Serializer Class, that inherits from the ModelSerializer. The base model for this serializer is the just created patient model. In the fields argument we may list all the fields we want to serialize. It is also possible to define __all__ or exclude certain fields. from rest_framework import serializers from dashboard.patients.models import Patient class PatientSerializer ( serializers . ModelSerializer ): class Meta : model = Patient fields = [ \"id\" , \"first_name\" , \"last_name\" , \"admission_date\" , \"dismissal_date\" , \"updated_at\" , \"created_at\" ] file: dashboard/patients/api/serializers.py","title":"Serializer"},{"location":"00_tut_ws/#consumer","text":"To be able to make the serialized data available to connected clients, a consumer needs to be set up. Clients that are connected to the WebSocket are called consumers . A fairly minimalistic setup looks something like this. Notice that a couple of Mixins are imported from the Django Channels Rest Framework , which provide the basic functionality. The serializer is the one we just created and the queryset is the one from the model above. To allow only authenticated users to connect, the permission_classes are set to \u00ecsAuthenticated . from djangochannelsrestframework import permissions from djangochannelsrestframework.generics import GenericAsyncAPIConsumer from djangochannelsrestframework.mixins import ( ListModelMixin , RetrieveModelMixin , UpdateModelMixin , PatchModelMixin , DeleteModelMixin , CreateModelMixin , ) from dashboard.patients.api.serializers import PatientSerializer from dashboard.patients.models import Patient class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,) file: dashboard/patients/consumers.py Info The Mixins that the consumer inherits from, are the actions that the WebSocket will provide. In the listing above you can e.g. see a ListModelMixin which will provide the list action for the consumer.","title":"Consumer"},{"location":"00_tut_ws/#urls","text":"Finally, we have to define a route for the WebSocket, just like with the REST API. The routes for the WebSockets are called streams and are defined in asgi.py . In this file you will find the ProtocolTypeRouter , that routes HTTP and WebSocket requests accordingly. Here, the starting point for the WebSocket is defined as /ws , whereas we defined the starting point for REST API endpoints as /api (not here). The stream we define here will be the string that follows the /ws/ . So in this case, our new route, that is connected to the PatientConsumer that we created in the previous step will be called patients . Notice, that within this definition, the patients is not declared with quotation marks. However, the resulting route/URL is www.example.com/ws/patients/ . But with an important change to the REST API endpoints, because instead of: http:// www.example.com/api/patients/ or https:// www.example.com/api/patients/ we now have a change in protocols and must use: ws:// ww.example.com/ws/patients/ or wss:// ww.example.com/ws/patients/ from channels.routing import ProtocolTypeRouter , URLRouter from django.core.asgi import get_asgi_application from django.urls import re_path from dashboard.patients.consumers import PatientConsumer from channelsmultiplexer import AsyncJsonWebsocketDemultiplexer from config.middleware import TokenAuthMiddlewareStack application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : TokenAuthMiddlewareStack ( URLRouter ( [ re_path ( r \"^ws/$\" , AsyncJsonWebsocketDemultiplexer ( patients = PatientConsumer () . as_asgi (), ) . as_asgi ()), ] ) ), }) file: config/asgi.py","title":"URLs"},{"location":"00_tut_ws_02/","text":"Send messages via WebSocket to clients In this tutorial we are going to notify each of the clients connected to the WebSocket about changes to the endpoint that was created in the last tutorial. Prerequisites Everything covered in the last Tutorial . Observer To be able to track changes in any instance of the Patient model, it is necessary, to implement an observer in the PatientConsumer that was created in the previous tutorial. The first change is to add the ObserverModelInstanceMixin from the Django Channels Rest Framework . class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer , ObserverModelInstanceMixin ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,) In a second step we are going to add our own custom Observer for this special model class that will be called `PatientConsumerObserver . class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer , ObserverModelInstanceMixin , PatientConsumerObserver ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,) PatientConsumerObserver A minimal setup for the PatientConsumerObserver may look something like this: class PatientConsumerObserver ( AsyncAPIConsumer ): async def accept ( self , ** kwargs ): await super () . accept ( ** kwargs ) await self . patient_change . subscribe () @model_observer ( Patient ) async def patient_change ( self , message , ** kwargs ): \"\"\" Observes changes of the patient model instances. :param message: The request/message from the consumer :param kwargs: Optional keyword arguments :return: Information about the change event via websocket messages in json format to the consumer \"\"\" await self . send_json ( message ) @patient_change . serializer def patient_serializer ( self , instance , action , ** kwargs ): \"\"\" Serializes the patient instance to be sent in json format to the consumer. :param instance: The patient instance :param action: Create, update, patch, list, delete :param kwargs: Optional keyword arguments :return: The serialized history instance \"\"\" return PatientSerializer ( instance ) . data Info All of the methods allow for the implementation of custom logic. However the accept method should somehow lead to the WebSocket accepting the request from a client to connect to the WebSocket stream. Sidenote: A customized disconnect method is also possible.","title":"Send messages via WebSocket to clients"},{"location":"00_tut_ws_02/#send-messages-via-websocket-to-clients","text":"In this tutorial we are going to notify each of the clients connected to the WebSocket about changes to the endpoint that was created in the last tutorial.","title":"Send messages via WebSocket to clients"},{"location":"00_tut_ws_02/#prerequisites","text":"Everything covered in the last Tutorial .","title":"Prerequisites"},{"location":"00_tut_ws_02/#observer","text":"To be able to track changes in any instance of the Patient model, it is necessary, to implement an observer in the PatientConsumer that was created in the previous tutorial. The first change is to add the ObserverModelInstanceMixin from the Django Channels Rest Framework . class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer , ObserverModelInstanceMixin ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,) In a second step we are going to add our own custom Observer for this special model class that will be called `PatientConsumerObserver . class PatientConsumer ( ListModelMixin , RetrieveModelMixin , PatchModelMixin , UpdateModelMixin , CreateModelMixin , DeleteModelMixin , GenericAsyncAPIConsumer , ObserverModelInstanceMixin , PatientConsumerObserver ): queryset = Patient . objects . all () serializer_class = PatientSerializer permission_classes = ( permissions . IsAuthenticated ,)","title":"Observer"},{"location":"00_tut_ws_02/#patientconsumerobserver","text":"A minimal setup for the PatientConsumerObserver may look something like this: class PatientConsumerObserver ( AsyncAPIConsumer ): async def accept ( self , ** kwargs ): await super () . accept ( ** kwargs ) await self . patient_change . subscribe () @model_observer ( Patient ) async def patient_change ( self , message , ** kwargs ): \"\"\" Observes changes of the patient model instances. :param message: The request/message from the consumer :param kwargs: Optional keyword arguments :return: Information about the change event via websocket messages in json format to the consumer \"\"\" await self . send_json ( message ) @patient_change . serializer def patient_serializer ( self , instance , action , ** kwargs ): \"\"\" Serializes the patient instance to be sent in json format to the consumer. :param instance: The patient instance :param action: Create, update, patch, list, delete :param kwargs: Optional keyword arguments :return: The serialized history instance \"\"\" return PatientSerializer ( instance ) . data Info All of the methods allow for the implementation of custom logic. However the accept method should somehow lead to the WebSocket accepting the request from a client to connect to the WebSocket stream. Sidenote: A customized disconnect method is also possible.","title":"PatientConsumerObserver"},{"location":"02_Installation/","text":"Installation This page serves as an installation guide for local development of the Dengue Dashboard . The guide assumes, that the reader already cloned a recent repository of the project and navigated to the project root. The shown commands are executed from the command line in the root directory if not declared otherwise. 1. Back end: Django Getting Up and Running Locally With Docker Info The project is not required to run in a docker container. All of the processes involved could also be started manually. However, for simplicity and cross-platform development purposes, a docker environment is provided. The steps below will get you up and running with a local development environment. All of these commands assume you are in the root of your generated project. See also: https://github.com/pydanny/cookiecutter-django/ Prerequisites Docker; if you don't have it yet, follow the installation instructions ; Docker Compose; refer to the official documentation for the installation guide . Build the Stack This can take a while, especially the first time you run this particular command on your development system: docker-compose -f local.yml build Generally, if you want to emulate production environment use production.yml instead. And this is true for any other actions you might need to perform: whenever a switch is required, just do it! Run the Stack This brings up both Django and PostgreSQL. The first time it is run it might take a while to get started, but subsequent runs will occur quickly. Open a terminal at the project root and run the following for local development: docker-compose -f local.yml up You can also set the environment variable COMPOSE_FILE pointing to local.yml like this: export COMPOSE_FILE=local.yml And then run: docker-compose up To run in a detached (background) mode, just:: docker-compose up -d (Optionally) Designate your Docker Development Server IP When DEBUG is set to True , the host is validated against ['localhost', '127.0.0.1', '[::1]'] . This is adequate when running a virtualenv . For Docker, in the config.settings.local , add your host development server IP to INTERNAL_IPS or ALLOWED_HOSTS if the variable exists. Alternative: Virtual Environment for Python Prerequisites : - Installation of: - Python 3 - pip - nodejs - npm/yarn - redis - postgres - a Unix/MacOS or Windows Machine As an alternative to Docker, the project can be developed in a virtual environment for python . To create a virtual environment, decide on a name, e.g. env_name and create on like so in a folder above or aside the project folder: python3 -m venv env_name To activate the virtual environment on a level above the environment folder that was just created: Mac OS / Linux source env_name/bin/activate Windows env_name\\Scripts\\activate.bat Back end With the virtual environment at hand (and activated), the requirements for the projects can now be installed manually only to this environment. To do so, you need to go to the root directory of the project and execute the following command: pip install requirements/local.txt After the installation is complete, the following command will start the server: python manage.py runserver The following commands are the same as in docker but without the docker specific prefix: python manage.py makemigrations python manage.py migrate python manage.py createsuperuser Front End Change to the vue_frontend directory. To initialize the frontend, from the vue_frontend directory, run: npm install To serve the Vue frontend in hot-reloading development mode together with the back end : npm run serve And to build for deployment: npm run build Additional Configurations When starting the server you may be prompted to provide right credentials for the database or redis. To find out, how to cofigure each of them for your OS, please refer to the specific documentations and provide the right credentials. NOTE: This approach is common when building django projects, however it is not tested for this specific project. Due to the scope of the project, it is highly reccomended to use the docker environment. For more information on virtual environments, please refer to the Python 3 tutorial: https://docs.python.org/3/tutorial/venv.html 2. Front end: Vue.js This app integrates with a Vue single page app (SPA) located in vue_frontend . To initialize the frontend, from the vue_frontend directory, run: npm install To serve the Vue frontend in hot-reloading development mode together with the back end : npm run serve And to build for deployment: npm run build Commands Execute Management Commands As with any shell command that we wish to run in our container, this is done using the docker-compose -f local.yml run --rm command: docker-compose -f local.yml run --rm django python manage.py migrate docker-compose -f local.yml run --rm django python manage.py createsuperuser Here, django is the target service we are executing the commands against. The run command is starting a new container that is being deleted after run due to the --rm flag. To achieve the same but in an already running container, you can use commands like: docker-compose -f local.yml exec django python manage.py migrate docker-compose -f local.yml exec --rm django python manage.py createsuperuser exec will use the existing container and run the given command in it. More on Docker and local development can be found in LOCAL_DEV.rst .","title":"Installation"},{"location":"02_Installation/#installation","text":"This page serves as an installation guide for local development of the Dengue Dashboard . The guide assumes, that the reader already cloned a recent repository of the project and navigated to the project root. The shown commands are executed from the command line in the root directory if not declared otherwise.","title":"Installation"},{"location":"02_Installation/#1-back-end-django","text":"","title":"1. Back end: Django"},{"location":"02_Installation/#getting-up-and-running-locally-with-docker","text":"Info The project is not required to run in a docker container. All of the processes involved could also be started manually. However, for simplicity and cross-platform development purposes, a docker environment is provided. The steps below will get you up and running with a local development environment. All of these commands assume you are in the root of your generated project. See also: https://github.com/pydanny/cookiecutter-django/","title":"Getting Up and Running Locally With Docker"},{"location":"02_Installation/#prerequisites","text":"Docker; if you don't have it yet, follow the installation instructions ; Docker Compose; refer to the official documentation for the installation guide .","title":"Prerequisites"},{"location":"02_Installation/#build-the-stack","text":"This can take a while, especially the first time you run this particular command on your development system: docker-compose -f local.yml build Generally, if you want to emulate production environment use production.yml instead. And this is true for any other actions you might need to perform: whenever a switch is required, just do it!","title":"Build the Stack"},{"location":"02_Installation/#run-the-stack","text":"This brings up both Django and PostgreSQL. The first time it is run it might take a while to get started, but subsequent runs will occur quickly. Open a terminal at the project root and run the following for local development: docker-compose -f local.yml up You can also set the environment variable COMPOSE_FILE pointing to local.yml like this: export COMPOSE_FILE=local.yml And then run: docker-compose up To run in a detached (background) mode, just:: docker-compose up -d (Optionally) Designate your Docker Development Server IP When DEBUG is set to True , the host is validated against ['localhost', '127.0.0.1', '[::1]'] . This is adequate when running a virtualenv . For Docker, in the config.settings.local , add your host development server IP to INTERNAL_IPS or ALLOWED_HOSTS if the variable exists. Alternative: Virtual Environment for Python Prerequisites : - Installation of: - Python 3 - pip - nodejs - npm/yarn - redis - postgres - a Unix/MacOS or Windows Machine As an alternative to Docker, the project can be developed in a virtual environment for python . To create a virtual environment, decide on a name, e.g. env_name and create on like so in a folder above or aside the project folder: python3 -m venv env_name To activate the virtual environment on a level above the environment folder that was just created: Mac OS / Linux source env_name/bin/activate Windows env_name\\Scripts\\activate.bat","title":"Run the Stack"},{"location":"02_Installation/#back-end","text":"With the virtual environment at hand (and activated), the requirements for the projects can now be installed manually only to this environment. To do so, you need to go to the root directory of the project and execute the following command: pip install requirements/local.txt After the installation is complete, the following command will start the server: python manage.py runserver The following commands are the same as in docker but without the docker specific prefix: python manage.py makemigrations python manage.py migrate python manage.py createsuperuser","title":"Back end"},{"location":"02_Installation/#front-end","text":"Change to the vue_frontend directory. To initialize the frontend, from the vue_frontend directory, run: npm install To serve the Vue frontend in hot-reloading development mode together with the back end : npm run serve And to build for deployment: npm run build","title":"Front End"},{"location":"02_Installation/#additional-configurations","text":"When starting the server you may be prompted to provide right credentials for the database or redis. To find out, how to cofigure each of them for your OS, please refer to the specific documentations and provide the right credentials. NOTE: This approach is common when building django projects, however it is not tested for this specific project. Due to the scope of the project, it is highly reccomended to use the docker environment. For more information on virtual environments, please refer to the Python 3 tutorial: https://docs.python.org/3/tutorial/venv.html","title":"Additional Configurations"},{"location":"02_Installation/#2-front-end-vuejs","text":"This app integrates with a Vue single page app (SPA) located in vue_frontend . To initialize the frontend, from the vue_frontend directory, run: npm install To serve the Vue frontend in hot-reloading development mode together with the back end : npm run serve And to build for deployment: npm run build","title":"2. Front end: Vue.js"},{"location":"02_Installation/#commands","text":"","title":"Commands"},{"location":"02_Installation/#execute-management-commands","text":"As with any shell command that we wish to run in our container, this is done using the docker-compose -f local.yml run --rm command: docker-compose -f local.yml run --rm django python manage.py migrate docker-compose -f local.yml run --rm django python manage.py createsuperuser Here, django is the target service we are executing the commands against. The run command is starting a new container that is being deleted after run due to the --rm flag. To achieve the same but in an already running container, you can use commands like: docker-compose -f local.yml exec django python manage.py migrate docker-compose -f local.yml exec --rm django python manage.py createsuperuser exec will use the existing container and run the given command in it. More on Docker and local development can be found in LOCAL_DEV.rst .","title":"Execute Management Commands"},{"location":"03_basics/","text":"Basics This section covers the overall basics of the project regarding the back end (Django) and the front end (Vue.js). The most important aspects to get started will be covered. System overview A brief overview over the system can be obtained from the following diagram: Main functionality For this application, the most important functions the back end and the front end have to provide are as follows: Back end Managing models and persist data in a database Handling the database connection Providing a a REST API Providing a WebSocket Handling WebSocket connections Managing users, authentication and sessions Front End Provide a user interface to interact with the database's data Management and visualization of vital data/patient's report data Basic management of patients Real-time updates without user interaction (WebSockets/Reactivity) Display notifications (received from the back end) WebSockets / Real-time communication The front end of this application works with data provided through WebSockets . WebSockets allow for full-duplex communication, meaning that both, the back end and the front end can send each other messages whenever they need to. Without the other one asking for it. This enables a real-time behaviour in the front end and works well together with the reactivity of Vue.js. Real-time communication and especially real-time updates can on the one hand be useful for tele-consultation, where all clients always have the same most recent data available on screen whithout the need to refresh manually. On the other hand the WebSockets enable the server to send notifications whenever it's needed and the client to receive them in time. However there is some data, that doesn't need to be transferred via WebSockets, like the authentication data. This data is handled using HTTP REST on both sides. Additionally, some other apps that will be integrated in the future might require normal REST API endpoints, which is why this project is structured to build the WebSockets endpoint on top of REST API endpoints, so that there are always both options. The following diagram illustrates the usage of HTTP and WebSockets:","title":"General"},{"location":"03_basics/#basics","text":"This section covers the overall basics of the project regarding the back end (Django) and the front end (Vue.js). The most important aspects to get started will be covered.","title":"Basics"},{"location":"03_basics/#system-overview","text":"A brief overview over the system can be obtained from the following diagram:","title":"System overview"},{"location":"03_basics/#main-functionality","text":"For this application, the most important functions the back end and the front end have to provide are as follows: Back end Managing models and persist data in a database Handling the database connection Providing a a REST API Providing a WebSocket Handling WebSocket connections Managing users, authentication and sessions Front End Provide a user interface to interact with the database's data Management and visualization of vital data/patient's report data Basic management of patients Real-time updates without user interaction (WebSockets/Reactivity) Display notifications (received from the back end)","title":"Main functionality"},{"location":"03_basics/#websockets-real-time-communication","text":"The front end of this application works with data provided through WebSockets . WebSockets allow for full-duplex communication, meaning that both, the back end and the front end can send each other messages whenever they need to. Without the other one asking for it. This enables a real-time behaviour in the front end and works well together with the reactivity of Vue.js. Real-time communication and especially real-time updates can on the one hand be useful for tele-consultation, where all clients always have the same most recent data available on screen whithout the need to refresh manually. On the other hand the WebSockets enable the server to send notifications whenever it's needed and the client to receive them in time. However there is some data, that doesn't need to be transferred via WebSockets, like the authentication data. This data is handled using HTTP REST on both sides. Additionally, some other apps that will be integrated in the future might require normal REST API endpoints, which is why this project is structured to build the WebSockets endpoint on top of REST API endpoints, so that there are always both options. The following diagram illustrates the usage of HTTP and WebSockets:","title":"WebSockets / Real-time communication"},{"location":"03_basics_backend/","text":"Model-View-Template (MVT) Django is following the Model-View-Template structure, where the Model is for structuring and manipulating the data of the application, the view implements the business logic and the templates serves the views to the clients. In this project, the templates are rendering the static files provided by the webpack bundling, that are moved into the static folder inside the back end directory after executing npm run build inside the vue_frontend directory. The principle of Django's MVT architecture is visualized in the following diagram: Source: https://www.javatpoint.com/django/images/django-mvt-based-control-flow.png Model The model of the application is to be found in the respective models.py file. See https://docs.djangoproject.com/en/3.2/topics/db/models for documentation on how to create Models and available Fields. All of the data of the model instances are saved to a PostgreSQL Database. Postgres integrates well with Django and Django even supports some fields exclusively for Postgres. See https://docs.djangoproject.com/en/3.2/ref/contrib/postgres/ View The view implements the business logic of the application. In the patients/api/views.py , the REST API endpoints are defined. The most important endpoints that are exposed as of the end of the thesis are: Endpoint Actions (REST) Description /api/patients/ GET, POST List view of all patients /api/patients/id/ GET, PUT, PATCH, DELETE Detail view of a single patient /api/reports/ GET, POST List view of all reports /api/reports/id/ GET, PUT, PATCH, DELETE Detail view of a single report /rest-auth/login/ POST Login with username and password /rest-auth/logout/ POST Logout and delete token /rest-auth/user/ GET Retrieve user information A full documentation of all available endpoints as well as an interactive demo of the endpoints can be obtained from the endpoint /swagger . Curl commands can be interactively executed on the page and requests and responses can be analysed. The fields, that are to be included (or excluded) in the respective JSON responses are defined in the patients/api/serializers.py file. Attention The front end of this application works with data provided through WebSockets . The aforementioned REST API endpoints are delivered via HTTP and useful for the integration of other services. The communication between the back end and the front end is mostly based on WebSockets however. WebSockets allow for full-duplex communication, meaning that both, the back end and the front end can send each other messages whenever they need to. Without the other one asking for it. This enables a real-time behaviour in the front end and works well together with the reactivity of Vue.js. However there is some data, that doesn't need to be transferred via WebSockets, like the authentication data. This data is handled using HTTP REST on both sides. The following diagram illustrates the usage of HTTP and WebSockets: With the WebSocket integration, the endpoints for WebSocket requests are defined like so: Stream Consumer Model Actions (REST-like) patients PatientConsumer Patient List, Retrieve, Create, Patch, Update, Delete reports ReportConsumer Report List, Retrieve, Create, Patch, Update, Delete history HistoryConsumer HistoricalReport List, Retrieve, Patch, Update, Delete The endpoints are defined in the asgi.py file of the Project. For more information see Routing . Template Django provides the option to create custom templates, i.e. write own HTML and extend it with special syntax, Django Template Language (DTL). These templates are, what the user is seeing in the browser. However it is also possible to define, which assets should be dynamically loaded into the page, like e.g. CSS and JS files, which is the case in this project. Routing The following code snippet from the asgi.py file shows the ProtocolTypeRouter that routes the HTTP and WebSocket requests according to their protocol types: application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : TokenAuthMiddlewareStack ( URLRouter ( [ re_path ( r \"^ws/$\" , AsyncJsonWebsocketDemultiplexer ( patients = PatientConsumer () . as_asgi (), reports = ReportConsumer () . as_asgi (), history = HistoryConsumer () . as_asgi (), ) . as_asgi ()), ] ) ), }) The streams are defined inside the Demultiplexer and connected to their respective consumer (see Consumer ). REST API The REST API endpoints are defined as described before (see View ). An endpoint definition consists of several files: patients/models.py patients/api/serializers.py patients/api/views.py patients/api/urls.py The files are to be created/updated in the order shown above. The model is the first thing, as it is the base to what will be possible to expose via an API endpoint. The serializer defines which fields are to be included or excluded into the serialized JSON response and is based on the model. The view is handling the serialized JSON and able to add orderings to the data or filters. Besides the textual JSON output of every response, the Django REST Framework is also serving a browsable API with web pages, where one can create, update and delete model instances inside the browser. To be able to request the endpoints via the given URLs, the created Views have to be registered and named in the patients/api/urls.py file. WebSocket Endpoints The REST API endpoints are defined as described before (see View ). A WebSocket endpoint needs a REST API endpoint as a base. On top of that, two additional files have to be modified: patients/consumers.py config/asgi.py The consumers define the business logic for the clients connected to the WebSocket. In asgi.py , a consumer is being attached to a stream and therefore a URL is being created to which the clients may connect from e.g. the front end. Consumer Consumers are an important part of the definition of WebSocket endpoints in this application. Consumers contain the business logic that is relevant for the clients, that are connected to the WebSocket. The behaviour for the connection setup or the disconnecion may be defined as well as - and especially - the behaviour for when the client is connected to the WebSocket. What kind of messages should be sent to the client? What format should the messages have? Should the messages be sent to all connected clients or just to specific ones? When should the message be sent? These are the most relevant questions, but there are many more. To summarize, how consumers work as of now (June 2021) in this application: Every relevant model, i.e. Patient , Report and ReportHistory has their own consumer. The querysets and serializers are set to the ones of the REST API endpoints. In addition, an observer model is implemented to make sure, that every change that is made to a model is reflected to all connected clients . This holds for all of the mentioned models. Because of the set serializers, the messages will display as defined in the REST API configuration. For the history model, there is an additionally custom type of message, called notification . Whenever the history model is changed, two computations are made. One is being triggered directly and sending a message to all connected clients, if a certain condition is met. Another one is being scheduled as a background task for a specific time. At this specific time, a message of the type notification will then be sent to all the clients that are connected at that time. For the consumers to work, they have to be connected to streams (see Routing ), which form URLs that a client can establish a connection to. In our case, a URL for the patient model would look something like this: wss://example.com/ws/patients/ Background Tasks Background Tasks are used in this application to send notifications via WebSockets at a specific time that is computed based on the input data. However, they can generally be used, to build up any kind of work queue. Tasks can be scheduled for specific times, may repeat, can be scheduled to be executed n seconds/minutes/hours(..) after a certain event and much more. In this application, a background task is e.g. scheduled to remind any connected client about an observation of a patient that is due, when it's time has come based on the time of the last observation and the monitoring interval. The background tasks of this application can be found in the patients/api/vies.py file and are decorated with the @background decorator. For more information on background tasks and possibilities, visit the official documentation: https://django-background-tasks.readthedocs.io/en/latest/","title":"Back end (Django)"},{"location":"03_basics_backend/#model-view-template-mvt","text":"Django is following the Model-View-Template structure, where the Model is for structuring and manipulating the data of the application, the view implements the business logic and the templates serves the views to the clients. In this project, the templates are rendering the static files provided by the webpack bundling, that are moved into the static folder inside the back end directory after executing npm run build inside the vue_frontend directory. The principle of Django's MVT architecture is visualized in the following diagram: Source: https://www.javatpoint.com/django/images/django-mvt-based-control-flow.png","title":"Model-View-Template (MVT)"},{"location":"03_basics_backend/#model","text":"The model of the application is to be found in the respective models.py file. See https://docs.djangoproject.com/en/3.2/topics/db/models for documentation on how to create Models and available Fields. All of the data of the model instances are saved to a PostgreSQL Database. Postgres integrates well with Django and Django even supports some fields exclusively for Postgres. See https://docs.djangoproject.com/en/3.2/ref/contrib/postgres/","title":"Model"},{"location":"03_basics_backend/#view","text":"The view implements the business logic of the application. In the patients/api/views.py , the REST API endpoints are defined. The most important endpoints that are exposed as of the end of the thesis are: Endpoint Actions (REST) Description /api/patients/ GET, POST List view of all patients /api/patients/id/ GET, PUT, PATCH, DELETE Detail view of a single patient /api/reports/ GET, POST List view of all reports /api/reports/id/ GET, PUT, PATCH, DELETE Detail view of a single report /rest-auth/login/ POST Login with username and password /rest-auth/logout/ POST Logout and delete token /rest-auth/user/ GET Retrieve user information A full documentation of all available endpoints as well as an interactive demo of the endpoints can be obtained from the endpoint /swagger . Curl commands can be interactively executed on the page and requests and responses can be analysed. The fields, that are to be included (or excluded) in the respective JSON responses are defined in the patients/api/serializers.py file. Attention The front end of this application works with data provided through WebSockets . The aforementioned REST API endpoints are delivered via HTTP and useful for the integration of other services. The communication between the back end and the front end is mostly based on WebSockets however. WebSockets allow for full-duplex communication, meaning that both, the back end and the front end can send each other messages whenever they need to. Without the other one asking for it. This enables a real-time behaviour in the front end and works well together with the reactivity of Vue.js. However there is some data, that doesn't need to be transferred via WebSockets, like the authentication data. This data is handled using HTTP REST on both sides. The following diagram illustrates the usage of HTTP and WebSockets: With the WebSocket integration, the endpoints for WebSocket requests are defined like so: Stream Consumer Model Actions (REST-like) patients PatientConsumer Patient List, Retrieve, Create, Patch, Update, Delete reports ReportConsumer Report List, Retrieve, Create, Patch, Update, Delete history HistoryConsumer HistoricalReport List, Retrieve, Patch, Update, Delete The endpoints are defined in the asgi.py file of the Project. For more information see Routing .","title":"View"},{"location":"03_basics_backend/#template","text":"Django provides the option to create custom templates, i.e. write own HTML and extend it with special syntax, Django Template Language (DTL). These templates are, what the user is seeing in the browser. However it is also possible to define, which assets should be dynamically loaded into the page, like e.g. CSS and JS files, which is the case in this project.","title":"Template"},{"location":"03_basics_backend/#routing","text":"The following code snippet from the asgi.py file shows the ProtocolTypeRouter that routes the HTTP and WebSocket requests according to their protocol types: application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : TokenAuthMiddlewareStack ( URLRouter ( [ re_path ( r \"^ws/$\" , AsyncJsonWebsocketDemultiplexer ( patients = PatientConsumer () . as_asgi (), reports = ReportConsumer () . as_asgi (), history = HistoryConsumer () . as_asgi (), ) . as_asgi ()), ] ) ), }) The streams are defined inside the Demultiplexer and connected to their respective consumer (see Consumer ).","title":"Routing"},{"location":"03_basics_backend/#rest-api","text":"The REST API endpoints are defined as described before (see View ). An endpoint definition consists of several files: patients/models.py patients/api/serializers.py patients/api/views.py patients/api/urls.py The files are to be created/updated in the order shown above. The model is the first thing, as it is the base to what will be possible to expose via an API endpoint. The serializer defines which fields are to be included or excluded into the serialized JSON response and is based on the model. The view is handling the serialized JSON and able to add orderings to the data or filters. Besides the textual JSON output of every response, the Django REST Framework is also serving a browsable API with web pages, where one can create, update and delete model instances inside the browser. To be able to request the endpoints via the given URLs, the created Views have to be registered and named in the patients/api/urls.py file.","title":"REST API"},{"location":"03_basics_backend/#websocket-endpoints","text":"The REST API endpoints are defined as described before (see View ). A WebSocket endpoint needs a REST API endpoint as a base. On top of that, two additional files have to be modified: patients/consumers.py config/asgi.py The consumers define the business logic for the clients connected to the WebSocket. In asgi.py , a consumer is being attached to a stream and therefore a URL is being created to which the clients may connect from e.g. the front end.","title":"WebSocket Endpoints"},{"location":"03_basics_backend/#consumer","text":"Consumers are an important part of the definition of WebSocket endpoints in this application. Consumers contain the business logic that is relevant for the clients, that are connected to the WebSocket. The behaviour for the connection setup or the disconnecion may be defined as well as - and especially - the behaviour for when the client is connected to the WebSocket. What kind of messages should be sent to the client? What format should the messages have? Should the messages be sent to all connected clients or just to specific ones? When should the message be sent? These are the most relevant questions, but there are many more. To summarize, how consumers work as of now (June 2021) in this application: Every relevant model, i.e. Patient , Report and ReportHistory has their own consumer. The querysets and serializers are set to the ones of the REST API endpoints. In addition, an observer model is implemented to make sure, that every change that is made to a model is reflected to all connected clients . This holds for all of the mentioned models. Because of the set serializers, the messages will display as defined in the REST API configuration. For the history model, there is an additionally custom type of message, called notification . Whenever the history model is changed, two computations are made. One is being triggered directly and sending a message to all connected clients, if a certain condition is met. Another one is being scheduled as a background task for a specific time. At this specific time, a message of the type notification will then be sent to all the clients that are connected at that time. For the consumers to work, they have to be connected to streams (see Routing ), which form URLs that a client can establish a connection to. In our case, a URL for the patient model would look something like this: wss://example.com/ws/patients/","title":"Consumer"},{"location":"03_basics_backend/#background-tasks","text":"Background Tasks are used in this application to send notifications via WebSockets at a specific time that is computed based on the input data. However, they can generally be used, to build up any kind of work queue. Tasks can be scheduled for specific times, may repeat, can be scheduled to be executed n seconds/minutes/hours(..) after a certain event and much more. In this application, a background task is e.g. scheduled to remind any connected client about an observation of a patient that is due, when it's time has come based on the time of the last observation and the monitoring interval. The background tasks of this application can be found in the patients/api/vies.py file and are decorated with the @background decorator. For more information on background tasks and possibilities, visit the official documentation: https://django-background-tasks.readthedocs.io/en/latest/","title":"Background Tasks"},{"location":"03_basics_frontend/","text":"Vue.js is a JavaScript Framework that enables for creating user interfaces. It consists of HTML, CSS and JS and allows to extend HTML with HTML attributes that are called directives. These directives offer functionality and can be either built-in like for-loops or user-defined. Vue.js itself is focused on the view layer. However with officially maintained packages, functionality for state-management, routing or build automation it can be extended. Components Components are reusable instances in Vue.js. Once created, they can be imported and used in the template of other components. A simple example of a component would look like this: < template > < h1 > This is an example component! </ h1 > </ template > < script > export default { name : 'foo-bar' , data (){ return {} } } </ script > < style scoped > </ style > Components typically consist of these sections: Template section: HTML Markup with Vue.js components Script section: \"Vue.js logic\" -> All the data, methods and lifecycle logic live here Style section: Not mandatory, but possible for e.g. scoped styling for the specific component With this component created, it can now be used like so in any other template: < div id = \"components-demo\" > < foo-bar ></ foo-bar > < h2 > Something here.. </ h2 > </ div > More on components is to be found in the official Vue.js documentation: https://vuejs.org/v2/guide/components.html Directives A minimal working example for the built-in directive that equals a for-loop looks like the following: < ul > < li v-for = \"item in items\" > {{item.text}} </ li > </ ul > The directive is called v-for and in this example iterates over the list object items . each individual object is assigned by the name item that is defined here. Within the html list tag the {{item.text}} is a statement to access the text attribute of the item object. The result of this would show a list of items with their text attributes, like the following: foo bar foobar bazbaz Routing To be able to see different views in the browser, it is important, to map created components to routes. For example a component Foo.vue would be mapped to the route /foo and Bar.vue might be mapped to /bar . This would look something like this: const routes = [ { path : '/foo' , component : Foo }, { path : '/bar' , component : Bar } ] This will make sure, that the Foo component will be rendered, when we are navigating to www.example.com/foo . The router of this application is to be found in vue_frontend/src/dashboard/entry/router.js . In addition to the simple mapping of routes and components, it is possible and also sometimes necessary to provide some business logic inside the router. For instance it is possible to make sure, that an unauthorized user is being redirected to the /login route. More on the vue-router is to be found at the official documentation: https://router.vuejs.org/guide/ State-management This application uses the state management pattern/library vuex, which is the official supported state management for Vue.js. Vuex provides a centralized store for all the data of the application and therefore for all the different components, so that the data can be managed centralized. There are rules, ensuring, that the state can only be modified predictably. The following diagram by Vuex/Vue.js gives an overview of the workflow with vuex: The communication between the front end and therefore the store and the Back-end API only happens through so called actions , which are defined in the state-management. Changes will be then commited to mutations which will then mutate the state . The state is what is rendered inside the components. Whenever a state of some data is changing, the component will be re-rendering, as long as the principles of Vue.js and vuex are kept. Inside vue components again, it is possible to trigger/dispatch such an action, that then again connects to a back-end API. More on vuex is to be found on the official documentation: https://vuex.vuejs.org/#what-is-a-state-management-pattern Static files / Deploying .vue files To be able to display .vue files in a browser, they have to be converted to static files , i.e. HTML, CSS and JS source files. This is happening by running the npm run build command. This triggers webpack , which bundles the .vue files to be deployed. See https://webpack.js.org/ for more information.","title":"Front end (Vue.js)"},{"location":"03_basics_frontend/#components","text":"Components are reusable instances in Vue.js. Once created, they can be imported and used in the template of other components. A simple example of a component would look like this: < template > < h1 > This is an example component! </ h1 > </ template > < script > export default { name : 'foo-bar' , data (){ return {} } } </ script > < style scoped > </ style > Components typically consist of these sections: Template section: HTML Markup with Vue.js components Script section: \"Vue.js logic\" -> All the data, methods and lifecycle logic live here Style section: Not mandatory, but possible for e.g. scoped styling for the specific component With this component created, it can now be used like so in any other template: < div id = \"components-demo\" > < foo-bar ></ foo-bar > < h2 > Something here.. </ h2 > </ div > More on components is to be found in the official Vue.js documentation: https://vuejs.org/v2/guide/components.html","title":"Components"},{"location":"03_basics_frontend/#directives","text":"A minimal working example for the built-in directive that equals a for-loop looks like the following: < ul > < li v-for = \"item in items\" > {{item.text}} </ li > </ ul > The directive is called v-for and in this example iterates over the list object items . each individual object is assigned by the name item that is defined here. Within the html list tag the {{item.text}} is a statement to access the text attribute of the item object. The result of this would show a list of items with their text attributes, like the following: foo bar foobar bazbaz","title":"Directives"},{"location":"03_basics_frontend/#routing","text":"To be able to see different views in the browser, it is important, to map created components to routes. For example a component Foo.vue would be mapped to the route /foo and Bar.vue might be mapped to /bar . This would look something like this: const routes = [ { path : '/foo' , component : Foo }, { path : '/bar' , component : Bar } ] This will make sure, that the Foo component will be rendered, when we are navigating to www.example.com/foo . The router of this application is to be found in vue_frontend/src/dashboard/entry/router.js . In addition to the simple mapping of routes and components, it is possible and also sometimes necessary to provide some business logic inside the router. For instance it is possible to make sure, that an unauthorized user is being redirected to the /login route. More on the vue-router is to be found at the official documentation: https://router.vuejs.org/guide/","title":"Routing"},{"location":"03_basics_frontend/#state-management","text":"This application uses the state management pattern/library vuex, which is the official supported state management for Vue.js. Vuex provides a centralized store for all the data of the application and therefore for all the different components, so that the data can be managed centralized. There are rules, ensuring, that the state can only be modified predictably. The following diagram by Vuex/Vue.js gives an overview of the workflow with vuex: The communication between the front end and therefore the store and the Back-end API only happens through so called actions , which are defined in the state-management. Changes will be then commited to mutations which will then mutate the state . The state is what is rendered inside the components. Whenever a state of some data is changing, the component will be re-rendering, as long as the principles of Vue.js and vuex are kept. Inside vue components again, it is possible to trigger/dispatch such an action, that then again connects to a back-end API. More on vuex is to be found on the official documentation: https://vuex.vuejs.org/#what-is-a-state-management-pattern","title":"State-management"},{"location":"03_basics_frontend/#static-files-deploying-vue-files","text":"To be able to display .vue files in a browser, they have to be converted to static files , i.e. HTML, CSS and JS source files. This is happening by running the npm run build command. This triggers webpack , which bundles the .vue files to be deployed. See https://webpack.js.org/ for more information.","title":"Static files / Deploying .vue files"},{"location":"04_backend/","text":"Back end This page shall provide more in-depth information on the structure of the back end and it's most important files. Structure The back end is structured in a way, that distinguishes between a local development environment and a production environment. Therefore some files such as the Dockerfile (see Installation ) are available twice. Depending on the environment, the respective files should either be used or are used automatically. Files marked with the word base such as config/settings/base.py - as the name suggests - serve as a base for both, the local and the production environment. . \u251c\u2500\u2500 .envs # environment variables, e.g. secret information \u251c\u2500\u2500 compose # contains the Dockerfiles \u2502 \u251c\u2500\u2500 local # - files for local development \u2502 \u2514\u2500\u2500 production # - files for production \u251c\u2500\u2500 config # back end configuration \u2502 \u2514\u2500\u2500 settings # django settings, grouped by local and production \u251c\u2500\u2500 dashboard \u2502 \u251c\u2500\u2500 contrib # by cookiecutter \u2502 \u251c\u2500\u2500 patients # app directory containing the model and API \u2502 \u251c\u2500\u2500 static # containing the static files from the front end \u2502 \u251c\u2500\u2500 templates # html templates to render static files, 404 templates etc. \u2502 \u251c\u2500\u2500 users # app directory containing user model (by cookiecutter) \u2502 \u251c\u2500\u2500 utils # by cookiecutter \u2502 \u2514\u2500\u2500 webpack_bundle # \u251c\u2500\u2500 docs # sphinx documentation (deprecated due to this one) \u2502 \u251c\u2500\u2500 _build \u2502 \u2514\u2500\u2500 _source \u251c\u2500\u2500 locale #output folder for translations \u251c\u2500\u2500 requirements #requirements grouped by local and production Getting started The most important folders, to get started with the back end are the following: config : The settings for the project are to be found in the config folder. dashboard/patients : This is the main app of the back end. It inherits the model definitions as well as the API's and the views. dashboard/patients/migrations : Migrations made for the patients model can be found in this folder. Migrations to other apps/models live in their respective folders. dashboard/static/vue : Just for information purposes: The static (HTML, CSS, JS..) files that are generated by the front end, will be transfered into this folder. dashboard/templates : Just for information purposes: Here lives the home.html which is the root of the app that is being served in the browser. requirements : All the requirements (dependencies) that are needed for development and/or production purposes. In the following, each of the different sections of the back end will be explained in more detail. env files Environment files are mainly used to store sensitive data such as passwords or secret keys that may cause vulnerabilities if exposed in the code. In local environments some things may be hardcoded, when they are depending on environment variables in production. This is an intended behaviour and should not be changed. See the config section and information about the settings. Most of the settings that require environment variables are defined there. .envs \u251c\u2500\u2500 .local \u2502 \u251c\u2500\u2500 .django \u2502 \u2514\u2500\u2500 .postgres \u2514\u2500\u2500 .production \u251c\u2500\u2500 .django \u2514\u2500\u2500 .postgres compose Except for the .yml files, all of the docker configuration is to be found in this directory. As usual, the configurations are separated by environments. . \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 django \u2502 \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2502 \u2514\u2500\u2500 start \u2502 \u2514\u2500\u2500 docs \u2502 \u2514\u2500\u2500 Dockerfile \u2514\u2500\u2500 production \u251c\u2500\u2500 django \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entrypoint \u2502 \u2514\u2500\u2500 start \u251c\u2500\u2500 postgres \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 maintenance \u2502 \u251c\u2500\u2500 _sourced \u2502 \u251c\u2500\u2500 backup \u2502 \u251c\u2500\u2500 backups \u2502 \u2514\u2500\u2500 restore \u2514\u2500\u2500 traefik \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 traefik.yml config The main settings of the software are to be found in the config folder. Whats normally the settings.py file, lives in the settings folder and is separated by environment. Because there are settings, that local and production environments have in common, there is also a base.py , that serves as the base. In a local environment, the settings of both the base.py and the local.py will be considered. \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_router.py \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 middleware.py \u251c\u2500\u2500 settings \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 base.py \u2502 \u251c\u2500\u2500 local.py \u2502 \u251c\u2500\u2500 production.py \u2502 \u2514\u2500\u2500 test.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py dashboard . \u251c\u2500\u2500 contrib \u2502 \u2514\u2500\u2500 sites \u2502 \u2514\u2500\u2500 migrations \u251c\u2500\u2500 patients \u2502 \u251c\u2500\u2500 api \u2502 \u2514\u2500\u2500 migrations \u251c\u2500\u2500 static \u2502 \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2514\u2500\u2500 favicons \u2502 \u251c\u2500\u2500 js \u2502 \u251c\u2500\u2500 sass \u2502 \u2514\u2500\u2500 vue \u2502 \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 img \u2502 \u2514\u2500\u2500 js \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 account \u2502 \u251c\u2500\u2500 pages \u2502 \u251c\u2500\u2500 users \u2502 \u2514\u2500\u2500 webpack_bundle \u251c\u2500\u2500 users \u2502 \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 utils \u2514\u2500\u2500 webpack_bundle \u2514\u2500\u2500 templatetags requirements The requirements follow the logic that was presented in the settings. base.txt is serving as a base for both local and production environments. Depending on the environment, the respective requirements will be installed additionally. The base.txt should only include what's needed in both environments. . \u251c\u2500\u2500 base.txt \u251c\u2500\u2500 local.txt \u2514\u2500\u2500 production.txt","title":"Project Structure"},{"location":"04_backend/#back-end","text":"This page shall provide more in-depth information on the structure of the back end and it's most important files.","title":"Back end"},{"location":"04_backend/#structure","text":"The back end is structured in a way, that distinguishes between a local development environment and a production environment. Therefore some files such as the Dockerfile (see Installation ) are available twice. Depending on the environment, the respective files should either be used or are used automatically. Files marked with the word base such as config/settings/base.py - as the name suggests - serve as a base for both, the local and the production environment. . \u251c\u2500\u2500 .envs # environment variables, e.g. secret information \u251c\u2500\u2500 compose # contains the Dockerfiles \u2502 \u251c\u2500\u2500 local # - files for local development \u2502 \u2514\u2500\u2500 production # - files for production \u251c\u2500\u2500 config # back end configuration \u2502 \u2514\u2500\u2500 settings # django settings, grouped by local and production \u251c\u2500\u2500 dashboard \u2502 \u251c\u2500\u2500 contrib # by cookiecutter \u2502 \u251c\u2500\u2500 patients # app directory containing the model and API \u2502 \u251c\u2500\u2500 static # containing the static files from the front end \u2502 \u251c\u2500\u2500 templates # html templates to render static files, 404 templates etc. \u2502 \u251c\u2500\u2500 users # app directory containing user model (by cookiecutter) \u2502 \u251c\u2500\u2500 utils # by cookiecutter \u2502 \u2514\u2500\u2500 webpack_bundle # \u251c\u2500\u2500 docs # sphinx documentation (deprecated due to this one) \u2502 \u251c\u2500\u2500 _build \u2502 \u2514\u2500\u2500 _source \u251c\u2500\u2500 locale #output folder for translations \u251c\u2500\u2500 requirements #requirements grouped by local and production Getting started The most important folders, to get started with the back end are the following: config : The settings for the project are to be found in the config folder. dashboard/patients : This is the main app of the back end. It inherits the model definitions as well as the API's and the views. dashboard/patients/migrations : Migrations made for the patients model can be found in this folder. Migrations to other apps/models live in their respective folders. dashboard/static/vue : Just for information purposes: The static (HTML, CSS, JS..) files that are generated by the front end, will be transfered into this folder. dashboard/templates : Just for information purposes: Here lives the home.html which is the root of the app that is being served in the browser. requirements : All the requirements (dependencies) that are needed for development and/or production purposes. In the following, each of the different sections of the back end will be explained in more detail. env files Environment files are mainly used to store sensitive data such as passwords or secret keys that may cause vulnerabilities if exposed in the code. In local environments some things may be hardcoded, when they are depending on environment variables in production. This is an intended behaviour and should not be changed. See the config section and information about the settings. Most of the settings that require environment variables are defined there. .envs \u251c\u2500\u2500 .local \u2502 \u251c\u2500\u2500 .django \u2502 \u2514\u2500\u2500 .postgres \u2514\u2500\u2500 .production \u251c\u2500\u2500 .django \u2514\u2500\u2500 .postgres compose Except for the .yml files, all of the docker configuration is to be found in this directory. As usual, the configurations are separated by environments. . \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 django \u2502 \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2502 \u2514\u2500\u2500 start \u2502 \u2514\u2500\u2500 docs \u2502 \u2514\u2500\u2500 Dockerfile \u2514\u2500\u2500 production \u251c\u2500\u2500 django \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 entrypoint \u2502 \u2514\u2500\u2500 start \u251c\u2500\u2500 postgres \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 maintenance \u2502 \u251c\u2500\u2500 _sourced \u2502 \u251c\u2500\u2500 backup \u2502 \u251c\u2500\u2500 backups \u2502 \u2514\u2500\u2500 restore \u2514\u2500\u2500 traefik \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 traefik.yml config The main settings of the software are to be found in the config folder. Whats normally the settings.py file, lives in the settings folder and is separated by environment. Because there are settings, that local and production environments have in common, there is also a base.py , that serves as the base. In a local environment, the settings of both the base.py and the local.py will be considered. \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_router.py \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 middleware.py \u251c\u2500\u2500 settings \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 base.py \u2502 \u251c\u2500\u2500 local.py \u2502 \u251c\u2500\u2500 production.py \u2502 \u2514\u2500\u2500 test.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py dashboard . \u251c\u2500\u2500 contrib \u2502 \u2514\u2500\u2500 sites \u2502 \u2514\u2500\u2500 migrations \u251c\u2500\u2500 patients \u2502 \u251c\u2500\u2500 api \u2502 \u2514\u2500\u2500 migrations \u251c\u2500\u2500 static \u2502 \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2514\u2500\u2500 favicons \u2502 \u251c\u2500\u2500 js \u2502 \u251c\u2500\u2500 sass \u2502 \u2514\u2500\u2500 vue \u2502 \u251c\u2500\u2500 css \u2502 \u251c\u2500\u2500 fonts \u2502 \u251c\u2500\u2500 img \u2502 \u2514\u2500\u2500 js \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 account \u2502 \u251c\u2500\u2500 pages \u2502 \u251c\u2500\u2500 users \u2502 \u2514\u2500\u2500 webpack_bundle \u251c\u2500\u2500 users \u2502 \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 utils \u2514\u2500\u2500 webpack_bundle \u2514\u2500\u2500 templatetags requirements The requirements follow the logic that was presented in the settings. base.txt is serving as a base for both local and production environments. Depending on the environment, the respective requirements will be installed additionally. The base.txt should only include what's needed in both environments. . \u251c\u2500\u2500 base.txt \u251c\u2500\u2500 local.txt \u2514\u2500\u2500 production.txt","title":"Structure"},{"location":"04_backend_admin/","text":"Django Admin The Django Admin page is an admin page built-in into django. It provides user management options and, if configurd, enables for managing the model instances. Django Admin Dashboard Customization To include custom apps and their respective models in the admin page, a file called admin.py has to be added to the root folder of the app . In our case, the app is patients . A file, adding the patient and the report model looks like this: from django.contrib import admin from simple_history.admin import SimpleHistoryAdmin from .models import Patient , Report admin . site . register ( Patient ) admin . site . register ( Report , SimpleHistoryAdmin )","title":"Django Admin"},{"location":"04_backend_admin/#django-admin","text":"The Django Admin page is an admin page built-in into django. It provides user management options and, if configurd, enables for managing the model instances. Django Admin Dashboard","title":"Django Admin"},{"location":"04_backend_admin/#customization","text":"To include custom apps and their respective models in the admin page, a file called admin.py has to be added to the root folder of the app . In our case, the app is patients . A file, adding the patient and the report model looks like this: from django.contrib import admin from simple_history.admin import SimpleHistoryAdmin from .models import Patient , Report admin . site . register ( Patient ) admin . site . register ( Report , SimpleHistoryAdmin )","title":"Customization"},{"location":"04_backend_apidocs/","text":"Browsable API The API of the project is available in form of a browsable API, where the JSON structure and meta data for each endpoint can be obtained. The browsable API can be found at /api/ API root at /api/ with all available endpoints Example of /api/patients/ with HTML Form to post data. Swagger OpenAPI Documentation A more in-depth documentation of the API endpoints can be found at /swagger/ . The swagger documentation provides a list of all endpoints of the application together with their respective REST methods (GET, POST, PUT, etc..), as well as a detailled model description and information on required fields and their formats. In addition to that, the documentation is interactive, which means that example requests can be made from within the browser. At the bottom of the page, swagger also provides a model documentation, which is especially useful for front end developers, who may not have insight or knowledge about the back-end model implementations. The model documentation provides descriptions about field types, names and required fields. /swagger/ documentation with a list of all endpoints grouped by models Example of /api/patients/ GET endpoint with additional information. Example of /api/patients/ GET endpoint with interactive mode (GET request and response). Model definition at the bottom of the API documentation.","title":"API Documentation"},{"location":"04_backend_apidocs/#browsable-api","text":"The API of the project is available in form of a browsable API, where the JSON structure and meta data for each endpoint can be obtained. The browsable API can be found at /api/ API root at /api/ with all available endpoints Example of /api/patients/ with HTML Form to post data.","title":"Browsable API"},{"location":"04_backend_apidocs/#swagger-openapi-documentation","text":"A more in-depth documentation of the API endpoints can be found at /swagger/ . The swagger documentation provides a list of all endpoints of the application together with their respective REST methods (GET, POST, PUT, etc..), as well as a detailled model description and information on required fields and their formats. In addition to that, the documentation is interactive, which means that example requests can be made from within the browser. At the bottom of the page, swagger also provides a model documentation, which is especially useful for front end developers, who may not have insight or knowledge about the back-end model implementations. The model documentation provides descriptions about field types, names and required fields. /swagger/ documentation with a list of all endpoints grouped by models Example of /api/patients/ GET endpoint with additional information. Example of /api/patients/ GET endpoint with interactive mode (GET request and response). Model definition at the bottom of the API documentation.","title":"Swagger OpenAPI Documentation"},{"location":"04_backend_local/","text":"This section goes more into detail on how to develop the backend locally. While the installation is covered on the installation page, this section also provides details on which settings one might configure for their specific environment. Local development As explained on the installation page, there are two different docker-compose files for each of the environment. For local development, the docker container is built and started by executing the following two commands in the root directory of the project. docker-compose local.yml -f build This first command builds the docker container and installs all of the necessary requirements for the back end. Because we are building the container for the local environment here, the requirements base.txt and local.txt will be installed. The following command starts the docker container. docker-compose local.yml -f up Together with django some other processes, including redis (cache) and postgres (database) will be started. After starting the docker container, the console output would look something like the following: redis | 1:M 19 May 2021 13:09:00.119 * Ready to accept connections postgres | 2021-05-19 13:09:01.875 UTC [26] LOG: database system was shut down at 2021-05-11 19:27:08 UTC postgres | 2021-05-19 13:09:01.895 UTC [1] LOG: database system is ready to accept connections django | PostgreSQL is available django | Operations to perform: django | Apply all migrations: admin, auth, authtoken, background_task, contenttypes, patients, sessions, sites, users django | Running migrations: django | No migrations to apply. django | INFO: Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit) The last line of the output shows the URL of the application. However, to fully be able to develop locally, pay attention to the Front End page. After the docker container is up and running, additional commands (like makemigrations e.g.), inside the container can be executed using the exec command: docker-compose -f local.yml exec django python manage.py makemigrations More content coming soon test websockets","title":"Local development"},{"location":"04_backend_local/#local-development","text":"As explained on the installation page, there are two different docker-compose files for each of the environment. For local development, the docker container is built and started by executing the following two commands in the root directory of the project. docker-compose local.yml -f build This first command builds the docker container and installs all of the necessary requirements for the back end. Because we are building the container for the local environment here, the requirements base.txt and local.txt will be installed. The following command starts the docker container. docker-compose local.yml -f up Together with django some other processes, including redis (cache) and postgres (database) will be started. After starting the docker container, the console output would look something like the following: redis | 1:M 19 May 2021 13:09:00.119 * Ready to accept connections postgres | 2021-05-19 13:09:01.875 UTC [26] LOG: database system was shut down at 2021-05-11 19:27:08 UTC postgres | 2021-05-19 13:09:01.895 UTC [1] LOG: database system is ready to accept connections django | PostgreSQL is available django | Operations to perform: django | Apply all migrations: admin, auth, authtoken, background_task, contenttypes, patients, sessions, sites, users django | Running migrations: django | No migrations to apply. django | INFO: Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit) The last line of the output shows the URL of the application. However, to fully be able to develop locally, pay attention to the Front End page. After the docker container is up and running, additional commands (like makemigrations e.g.), inside the container can be executed using the exec command: docker-compose -f local.yml exec django python manage.py makemigrations More content coming soon test websockets","title":"Local development"},{"location":"04_backend_production/","text":"The most important difference between the local and the production environment are the environment variables . Not only, but mostly sensitive information is stored in environment variables and will not be exported from a local environment to a production environment. Therefore these environment variables have to be set in the production environment. It is suggested not to hardcode values for such variables into the code for production, but to really set and use environment variables. Configuring the environment environment variables The environment files can be found in the .envs directory like shown before. The most important thing for us here now is env_file section enlisting ./.envs/.local/.postgres . Generally, the stack's behavior is governed by a number of environment variables ( env(s) , for short) residing in envs/ . # PostgreSQL # ------------------------------------------------------------------------------ POSTGRES_HOST=postgres POSTGRES_DB=<your project slug> POSTGRES_USER=<your postgres user> POSTGRES_PASSWORD=<your password> ...","title":"Production"},{"location":"04_backend_production/#configuring-the-environment","text":"environment variables The environment files can be found in the .envs directory like shown before. The most important thing for us here now is env_file section enlisting ./.envs/.local/.postgres . Generally, the stack's behavior is governed by a number of environment variables ( env(s) , for short) residing in envs/ . # PostgreSQL # ------------------------------------------------------------------------------ POSTGRES_HOST=postgres POSTGRES_DB=<your project slug> POSTGRES_USER=<your postgres user> POSTGRES_PASSWORD=<your password> ...","title":"Configuring the environment"},{"location":"05_frontend/","text":"Front end Attention More content coming soon. This page shall provide more in-depth information on the structure of the front end and it's most important files. Structure The main directory of the front end is the vue_frontend folder. It's structure presents as follows on the first level: . \u251c\u2500\u2500 .env # environment variables, e.g. secret information \u251c\u2500\u2500 .browserslistrc # info about supported browsers \u251c\u2500\u2500 .eslintrc.js # linting configuration \u251c\u2500\u2500 .gitignore # files to be ignored by VCS \u251c\u2500\u2500 README.md # little guide to get started \u251c\u2500\u2500 babel.config.js # babel configurations \u251c\u2500\u2500 node_modules # directory with all installed node dependencies (created by \"npm install\") \u251c\u2500\u2500 package-lock.json # file with the exact versions of all dependencies so that a product is 100% reproducible even after updates \u251c\u2500\u2500 package.json # metadata and dependencies \u251c\u2500\u2500 src # directory with the source code of the front end \u251c\u2500\u2500 vue.config.js # webpack configuration \u2514\u2500\u2500 webpack-stats.json # webpack info Important files in the root directory .env : Environment variables for the front end README.md : Quickstart with commands for development node_modules : Auto-generated folder by running npm install that inherits all dependencies package.json : Metadata and dependencies src : Source code of the project vue.config.js : Webpack configuration Source Code As mentioned in the previous section, the source code of the front end is to be found in the src directory. It is a Vue App consisting of multiple .vue files that are divided into components or more complex layouts. For the state-management of the app, a store is set up. Everything related to the state-management is to be found inside the store directory. . \u251c\u2500\u2500 App.vue \u251c\u2500\u2500 dashboard \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 components \u2502 \u251c\u2500\u2500 directives \u2502 \u251c\u2500\u2500 entry \u2502 \u2502 \u251c\u2500\u2500 main.js \u2502 \u2502 \u251c\u2500\u2500 registerServiceWorker.js \u2502 \u2502 \u2514\u2500\u2500 router.js \u2502 \u251c\u2500\u2500 layout \u2502 \u251c\u2500\u2500 plugins \u2502 \u2514\u2500\u2500 views \u2514\u2500\u2500 store \u251c\u2500\u2500 modules \u2514\u2500\u2500 vuex_usage_utils.js Getting started with the front end main.js : Entrypoint for the app. Connects the store, the router, the App and everything that is needed. router.js : Defines the routes for the app and connects components/layouts and names to them. App.vue : The main structure of the app that is rendered at first. vuex_usage_utils.js : The store/state-management configurations. The store The data of the application is managed inside the store folder. The vuex_usage_utils.js file describes the modules, the connections, what is stored in the browser cache and what not etc. And inside the modules folder there are and can be logically structured subfolders and files containing business logic for the datahandling itself. In the case of this application this is the communication between the front end and the back end and some necessary operations on the data that the front end has to do. The substructure of the modules folder might present itself like so : . \u251c\u2500\u2500 modules \u2502 \u251c\u2500\u2500 auth # authentication-related logic \u2502 \u2502 \u251c\u2500\u2500 csrf_token.js # helper file \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 dengue # DD/DHF-related logic \u2502 \u2502 \u2514\u2500\u2500 dengue.js \u2502 \u251c\u2500\u2500 notifications # notification-related logic \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 patients # patient-related logic \u2502 \u2502 \u2514\u2500\u2500 patient.js \u2502 \u251c\u2500\u2500 reports # report-related logic \u2502 \u2502 \u2514\u2500\u2500 reports.js \u2502 \u2514\u2500\u2500 socket # socket-related logic \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 vuex_usage_utils.js # management file","title":"Project Structure"},{"location":"05_frontend/#front-end","text":"Attention More content coming soon. This page shall provide more in-depth information on the structure of the front end and it's most important files.","title":"Front end"},{"location":"05_frontend/#structure","text":"The main directory of the front end is the vue_frontend folder. It's structure presents as follows on the first level: . \u251c\u2500\u2500 .env # environment variables, e.g. secret information \u251c\u2500\u2500 .browserslistrc # info about supported browsers \u251c\u2500\u2500 .eslintrc.js # linting configuration \u251c\u2500\u2500 .gitignore # files to be ignored by VCS \u251c\u2500\u2500 README.md # little guide to get started \u251c\u2500\u2500 babel.config.js # babel configurations \u251c\u2500\u2500 node_modules # directory with all installed node dependencies (created by \"npm install\") \u251c\u2500\u2500 package-lock.json # file with the exact versions of all dependencies so that a product is 100% reproducible even after updates \u251c\u2500\u2500 package.json # metadata and dependencies \u251c\u2500\u2500 src # directory with the source code of the front end \u251c\u2500\u2500 vue.config.js # webpack configuration \u2514\u2500\u2500 webpack-stats.json # webpack info Important files in the root directory .env : Environment variables for the front end README.md : Quickstart with commands for development node_modules : Auto-generated folder by running npm install that inherits all dependencies package.json : Metadata and dependencies src : Source code of the project vue.config.js : Webpack configuration","title":"Structure"},{"location":"05_frontend/#source-code","text":"As mentioned in the previous section, the source code of the front end is to be found in the src directory. It is a Vue App consisting of multiple .vue files that are divided into components or more complex layouts. For the state-management of the app, a store is set up. Everything related to the state-management is to be found inside the store directory. . \u251c\u2500\u2500 App.vue \u251c\u2500\u2500 dashboard \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 components \u2502 \u251c\u2500\u2500 directives \u2502 \u251c\u2500\u2500 entry \u2502 \u2502 \u251c\u2500\u2500 main.js \u2502 \u2502 \u251c\u2500\u2500 registerServiceWorker.js \u2502 \u2502 \u2514\u2500\u2500 router.js \u2502 \u251c\u2500\u2500 layout \u2502 \u251c\u2500\u2500 plugins \u2502 \u2514\u2500\u2500 views \u2514\u2500\u2500 store \u251c\u2500\u2500 modules \u2514\u2500\u2500 vuex_usage_utils.js Getting started with the front end main.js : Entrypoint for the app. Connects the store, the router, the App and everything that is needed. router.js : Defines the routes for the app and connects components/layouts and names to them. App.vue : The main structure of the app that is rendered at first. vuex_usage_utils.js : The store/state-management configurations.","title":"Source Code"},{"location":"05_frontend/#the-store","text":"The data of the application is managed inside the store folder. The vuex_usage_utils.js file describes the modules, the connections, what is stored in the browser cache and what not etc. And inside the modules folder there are and can be logically structured subfolders and files containing business logic for the datahandling itself. In the case of this application this is the communication between the front end and the back end and some necessary operations on the data that the front end has to do. The substructure of the modules folder might present itself like so : . \u251c\u2500\u2500 modules \u2502 \u251c\u2500\u2500 auth # authentication-related logic \u2502 \u2502 \u251c\u2500\u2500 csrf_token.js # helper file \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 dengue # DD/DHF-related logic \u2502 \u2502 \u2514\u2500\u2500 dengue.js \u2502 \u251c\u2500\u2500 notifications # notification-related logic \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 patients # patient-related logic \u2502 \u2502 \u2514\u2500\u2500 patient.js \u2502 \u251c\u2500\u2500 reports # report-related logic \u2502 \u2502 \u2514\u2500\u2500 reports.js \u2502 \u2514\u2500\u2500 socket # socket-related logic \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 vuex_usage_utils.js # management file","title":"The store"},{"location":"05_frontend_local/","text":"This section goes more into detail on how to develop the front end locally. While the installation is covered on the installation page, this section also provides details on which settings one might configure for their specific environment. After the installation of all npm modules, the most important command to get things running in a local environment is: npm run serve This will serve the Vue.js App locally. Keep in mind that you should have the Docker container with the backend running locally as well to be able to exchange data. The terminal is going to give some output similar to this: DONE Compiled successfully in 6342ms 11:57:49 AM App running at: - Local: http://localhost:8080/ - Network: http://localhost:8080/ Note that the development build is not optimized. To create a production build, run npm run build. However, due to the configurations, you should be able to reach the page at http://localhost:8000 , which is recommended, as everything else (such as the Django Admin panel, the API Docs etc.) are also operating on this port. Hot reloading Developing in Vue.js and serving the web app as shown before should enable you to see changes made to the app immediately without restarting anything. This is called hot reloading and might be familiar when someone is experienced in flutter or something like that. However, this system has it's flaws and might not work as expected from time to time. This may be due to several reasons. A good idea in this case is to 1. try and quit the process and restart npm run serve or in a harder case 2. quit the process, delete all caches and restart npm run serve or as a last option 3. quit the process, delete all caches, run npm run build and then restart npm run serve . Vue.js Plugin Besides the Hot Reload functionality, that makes developing in Vue.js very comfortable, the Vue.js Plugin for Chromium-based browsers comes in very handy as well. The Vue.js devtools provide functionality such as browsing through the different components and observing different states of data objects. In addition to that it is possible to track the vuex flow, i.e. the triggering events, the mutations and the states before and after a mutation was made. source: https://raw.githubusercontent.com/vuejs/devtools/main/media/screenshot-shadow.png Debug/track WebSocket messages Via the devtools in every modern browser it is possible to track the websocket messages that are being exchanged between the back end and the front end. However, one needs to pay respect to some peculiarities. The following shows, how debugging/tracking WebSocket messages in general works. Open the devtools of the browser Navigate to the Network tab Inside the Network tab choose WS (WebSockets) Navigate to the page you want to inspect the WebSocket communication on or reload the page you are on Outgoing messages are marked with an arrow pointing upwards, whereas incoming messages are marked with an arrow pointing downwards Outgoing message from front end to back end. Request to list all patients. Incoming message from back end to front end. Response with a list of all patients. It is possible to unfold single parts of the response such as single patients and retrieve more information.","title":"Local development"},{"location":"05_frontend_local/#hot-reloading","text":"Developing in Vue.js and serving the web app as shown before should enable you to see changes made to the app immediately without restarting anything. This is called hot reloading and might be familiar when someone is experienced in flutter or something like that. However, this system has it's flaws and might not work as expected from time to time. This may be due to several reasons. A good idea in this case is to 1. try and quit the process and restart npm run serve or in a harder case 2. quit the process, delete all caches and restart npm run serve or as a last option 3. quit the process, delete all caches, run npm run build and then restart npm run serve .","title":"Hot reloading"},{"location":"05_frontend_local/#vuejs-plugin","text":"Besides the Hot Reload functionality, that makes developing in Vue.js very comfortable, the Vue.js Plugin for Chromium-based browsers comes in very handy as well. The Vue.js devtools provide functionality such as browsing through the different components and observing different states of data objects. In addition to that it is possible to track the vuex flow, i.e. the triggering events, the mutations and the states before and after a mutation was made. source: https://raw.githubusercontent.com/vuejs/devtools/main/media/screenshot-shadow.png","title":"Vue.js Plugin"},{"location":"05_frontend_local/#debugtrack-websocket-messages","text":"Via the devtools in every modern browser it is possible to track the websocket messages that are being exchanged between the back end and the front end. However, one needs to pay respect to some peculiarities. The following shows, how debugging/tracking WebSocket messages in general works. Open the devtools of the browser Navigate to the Network tab Inside the Network tab choose WS (WebSockets) Navigate to the page you want to inspect the WebSocket communication on or reload the page you are on Outgoing messages are marked with an arrow pointing upwards, whereas incoming messages are marked with an arrow pointing downwards Outgoing message from front end to back end. Request to list all patients. Incoming message from back end to front end. Response with a list of all patients. It is possible to unfold single parts of the response such as single patients and retrieve more information.","title":"Debug/track WebSocket messages"},{"location":"05_frontend_production/","text":"More content coming soon webpack","title":"Production"},{"location":"06_faq/","text":"Frequently Asked Questions How to approach the project? The general structure of the project is divided into two parts: back end and front end. The back end is made with Django, a web framework based on python . The front end is made with Vue.js. Vue.js consists of JavaScript, HTML and CSS. Both, Django and Vue.js are fairly easy to learn. Back end / Django First of all, the Django project itself is providing useful resources to get started with Django: Django Project For this project, for django a good start would also be the documentation of the Django REST Framework , as the back end provides an API for different applications. See Django REST Framework The Dengue Dashboard in particular is based on being a real-time web-application and therefore uses a full-duplex communication between the server and the client. That means that both, client and server, may always send each other messages after an initial connection is established. That couldn't be provided with normal HTTP REST communication as previous mentioned. For this purpose, the WebSocket protocol was implemented into the project, which made it necessary to implement Django Channels , that enables channeling the different protocols (HTTP/WebSockets). An incredibly useful article , to understand the structure of this project and the overview of handling different protocols in a real-time environment is to be found here: https://blog.heroku.com/in_deep_with_django_channels_the_future_of_real_time_apps_in_django . It is written by one of the core developers of Django and not only helps to understand the structure of this project, but also visualizes the concepts of Django Channels. To serve the API via WebSockets , the Django Channels REST Framework was used. In general, it is possible and common to serve .html files from the Django Templates folder. You can write html and specific Django syntax to render pages that will be served to the client. For this project however, Vue.js is used to create the files for the front end and display information to the client. The reason for this is, that Vue.js is a reactive JavaScript framework. It enables automatic updating of the page/DOM in case of updates to the data that is being displayed. Furthermore, with a JavaScript framework like this, it is possible to separate the data from it's representation. The front end is solely developed in the vue_frontend directory, whilst all of the other folders are connected to the back end. Besides Django, the back end also includes other frameworks/technologies that are e.g. used for deployment. To fully understand the files of the back end, one could look at the following technologies, that are used: Python Django (as a web framework based on python) Docker/Dockerfiles Shell Scripts Markdown (for Documentation purposes mostly) pip (package manager to install python packages) JSON Knowledge of the terminal Front end / Vue.js The front end of the application is developed with Vue.js. The main reason besides the separation of content and representation is the reactivity. Through state-management it is possible, that the DOM automatically refreshes whenever changes to the represented data is made. This enhances the real-time feature of the web-application. Vue has got several other advantages such as that it is light-weighted and incrementally adoptable, thus scalable. A good starting point for Vue.js is the project website itself. Vue.js is open-source and well-documented. https://vuejs.org/v2/guide/ To connect with the aforementioned WebSocket provided by the Django Channels REST Framework, a client side implementation is used. The maybe most important part in the front end implementation is the state-management. Vuex is a state-management pattern and library for Vue.js. The documentation for vuex delivers a good explanation of what vuex is and how it works. https://vuex.vuejs.org/ The following diagram gives a brief overview over the vuex state-management pattern from the aforementioned website. To fully understand the files of the front end, one could look at the following technologies: JavaScript HTML CSS Bootstrap (as a CSS framework that is used in the front end template) npm (package manager to install javascript packages) Vue.js Vuex (state-management) Single Page Applications WebPack (Bundling files into static assets) JSON Developer Tools of your Browser of Choice (Chrome or Firefox are recommended) Which IDE is recommended? Front end I would recommend PyCharm Professional together with the Vue.js PlugIn. It is a powerful IDE for Python development but with support for Vue.js and comes with rich features regarding project navigation, highlighting, code completion, TODO management, integrated terminal or python console etc. It is developed by JetBrains and free of charge for students. Great and useful features for a project this size, are: Structure view: Cmd+7 (Mac) / Alt+7 (Win) Find file by name: Shift+Cmd+O (Mac) / Ctrl+F12 (Win) Find in files: Shift+Cmd+F (Mac) / Ctrl+Shift+F (Win) All Shortcuts for Win/Linux: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard.pdf All Shortcuts for MacOS: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard_mac.pdf As an Alternative to PyCharm I would recommend Virtual Studio Code with Plugins for Vue.js. Back end I would recommend PyCharm Professional . It is a powerful IDE for Python development but with support for Vue.js and comes with rich features regarding project navigation, highlighting, code completion, TODO management, integrated terminal or python console etc. It is developed by JetBrains and free of charge for students. Great and useful features for a project this size, are: Structure view: Cmd+7 (Mac) / Alt+7 (Win) Find file by name: Shift+Cmd+O (Mac) / Ctrl+F12 (Win) Find in files: Shift+Cmd+F (Mac) / Ctrl+Shift+F (Win) All Shortcuts for Win/Linux: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard.pdf All Shortcuts for MacOS: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard_mac.pdf As an alternative, Virtual Studio Code will work, but needs Plugins to feel like an IDE. Which programs are recommended? Front end Operating Systems: macOs, Linux, Windows (mind the problems) IDEs : PyCharm Professional, Visual Studio Code Browser : Brave, Chrome, Firefox (Chromium-based Browsers with Vue.js Plugin) Misc: Docker, npm Back end Operating Systems: macOs, Linux, Windows (mind the problems) IDEs : PyCharm Professional, Visual Studio Code Programs: DBeaver Browser : Brave, Chrome, Firefox (Chromium-based Browsers with Vue.js Plugin) Misc: Docker What are the programming languages/technologies that are used? Front end HTML, CSS, JS Vue.js Bootstrap JSON Back end Python Django PostgreSQL Shell Docker JSON localhost:8000 is not showing the app. You started Docker but localhost:8000 is not showing the App? There is a couple of things that could be wrong here. Front end is not up and running First of all, make sure, that the front end is being served. You can achieve this by running npm install once and then npm run serve inside the vue_frontend directory of the project. npm run serve will serve the front end and enable hot reloading, which means that all changes made to the code will automatically refresh the page in the browser after saving the file. Cache is broken The app is made to make as little requests as necessary. That means, if some JavaScript or CSS file that is needed for the page was already loaded into the cache once, the page will most likely not request the same file again unless the file is marked as modified. This is one reason, why the webpack configuration, that bundles the front end .vue files to static .js and .css files generates a unique hash that is appended to every file. The files will be renewed in the browser after every build process. In local development however, the development cycle might lead to a broken cache, i.e. a cache, where files are mistaken to be the newest when they aren't. The easiest way to verify if that is the problem you are encountering is to delete the cached files or to see if the problem persists in a private window. Personal experience showed, that these caching problems in local development rarely occur, when building the project with npm run build after a developing session. Serving in the wrong location The standard port of local development for Vue.js is :8080 whereas the Docker will serve on port :8000 . Both will work, but localhost:8000 is preferable and used throughout the application. Depending on your system/machine it is possible, that localhost or 0.0.0.0 or 127.0.0.1 is not the IP that your Docker instance is serving the app on. Another possibility is, that the ports are not available to your host system or blocked by the firewall. Vue.js will usually automatically turn to another port then but in cases might not. So for debugging, you might follow these steps: https://stackoverflow.com/questions/46176584/docker-bind-for-0-0-0-04000-failed-port-is-already-allocated Check your firewall settings for the ports Check the IP/Port of your docker process(es) When you encounter another IP than any of the localhost IPs, it is important to whitelist them in the django app ( ALLOWED_HOSTS ) and also to exchange all strings containing the localhost URL to your new IP. The ALLOWED_HOSTS can e.g. be altered in config/settings/local.py . More information on ALLOWED_HOSTS: https://docs.djangoproject.com/en/dev/ref/settings/#allowed-hosts I've got problems with Docker on Windows... Windows is the least recommended Operation System. It seems to be well known, that there are problems when Hyper-V and VirtualBox coexist in a Windows installation. This could lead to problems if you e.g. use something like VirtualBox on your Windows machine and want to install/use Docker (using Hyper-V) as well. Further information on this: https://www.mt-ag.com/blog/ki-werkstatt/koexistenz-von-hyper-v-und-virtualbox-fur-den-einsatz-von-docker/","title":"FAQ"},{"location":"06_faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"06_faq/#how-to-approach-the-project","text":"The general structure of the project is divided into two parts: back end and front end. The back end is made with Django, a web framework based on python . The front end is made with Vue.js. Vue.js consists of JavaScript, HTML and CSS. Both, Django and Vue.js are fairly easy to learn.","title":"How to approach the project?"},{"location":"06_faq/#back-end-django","text":"First of all, the Django project itself is providing useful resources to get started with Django: Django Project For this project, for django a good start would also be the documentation of the Django REST Framework , as the back end provides an API for different applications. See Django REST Framework The Dengue Dashboard in particular is based on being a real-time web-application and therefore uses a full-duplex communication between the server and the client. That means that both, client and server, may always send each other messages after an initial connection is established. That couldn't be provided with normal HTTP REST communication as previous mentioned. For this purpose, the WebSocket protocol was implemented into the project, which made it necessary to implement Django Channels , that enables channeling the different protocols (HTTP/WebSockets). An incredibly useful article , to understand the structure of this project and the overview of handling different protocols in a real-time environment is to be found here: https://blog.heroku.com/in_deep_with_django_channels_the_future_of_real_time_apps_in_django . It is written by one of the core developers of Django and not only helps to understand the structure of this project, but also visualizes the concepts of Django Channels. To serve the API via WebSockets , the Django Channels REST Framework was used. In general, it is possible and common to serve .html files from the Django Templates folder. You can write html and specific Django syntax to render pages that will be served to the client. For this project however, Vue.js is used to create the files for the front end and display information to the client. The reason for this is, that Vue.js is a reactive JavaScript framework. It enables automatic updating of the page/DOM in case of updates to the data that is being displayed. Furthermore, with a JavaScript framework like this, it is possible to separate the data from it's representation. The front end is solely developed in the vue_frontend directory, whilst all of the other folders are connected to the back end. Besides Django, the back end also includes other frameworks/technologies that are e.g. used for deployment. To fully understand the files of the back end, one could look at the following technologies, that are used: Python Django (as a web framework based on python) Docker/Dockerfiles Shell Scripts Markdown (for Documentation purposes mostly) pip (package manager to install python packages) JSON Knowledge of the terminal","title":"Back end / Django"},{"location":"06_faq/#front-end-vuejs","text":"The front end of the application is developed with Vue.js. The main reason besides the separation of content and representation is the reactivity. Through state-management it is possible, that the DOM automatically refreshes whenever changes to the represented data is made. This enhances the real-time feature of the web-application. Vue has got several other advantages such as that it is light-weighted and incrementally adoptable, thus scalable. A good starting point for Vue.js is the project website itself. Vue.js is open-source and well-documented. https://vuejs.org/v2/guide/ To connect with the aforementioned WebSocket provided by the Django Channels REST Framework, a client side implementation is used. The maybe most important part in the front end implementation is the state-management. Vuex is a state-management pattern and library for Vue.js. The documentation for vuex delivers a good explanation of what vuex is and how it works. https://vuex.vuejs.org/ The following diagram gives a brief overview over the vuex state-management pattern from the aforementioned website. To fully understand the files of the front end, one could look at the following technologies: JavaScript HTML CSS Bootstrap (as a CSS framework that is used in the front end template) npm (package manager to install javascript packages) Vue.js Vuex (state-management) Single Page Applications WebPack (Bundling files into static assets) JSON Developer Tools of your Browser of Choice (Chrome or Firefox are recommended)","title":"Front end / Vue.js"},{"location":"06_faq/#which-ide-is-recommended","text":"Front end I would recommend PyCharm Professional together with the Vue.js PlugIn. It is a powerful IDE for Python development but with support for Vue.js and comes with rich features regarding project navigation, highlighting, code completion, TODO management, integrated terminal or python console etc. It is developed by JetBrains and free of charge for students. Great and useful features for a project this size, are: Structure view: Cmd+7 (Mac) / Alt+7 (Win) Find file by name: Shift+Cmd+O (Mac) / Ctrl+F12 (Win) Find in files: Shift+Cmd+F (Mac) / Ctrl+Shift+F (Win) All Shortcuts for Win/Linux: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard.pdf All Shortcuts for MacOS: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard_mac.pdf As an Alternative to PyCharm I would recommend Virtual Studio Code with Plugins for Vue.js. Back end I would recommend PyCharm Professional . It is a powerful IDE for Python development but with support for Vue.js and comes with rich features regarding project navigation, highlighting, code completion, TODO management, integrated terminal or python console etc. It is developed by JetBrains and free of charge for students. Great and useful features for a project this size, are: Structure view: Cmd+7 (Mac) / Alt+7 (Win) Find file by name: Shift+Cmd+O (Mac) / Ctrl+F12 (Win) Find in files: Shift+Cmd+F (Mac) / Ctrl+Shift+F (Win) All Shortcuts for Win/Linux: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard.pdf All Shortcuts for MacOS: https://resources.jetbrains.com/storage/products/pycharm/docs/PyCharm_ReferenceCard_mac.pdf As an alternative, Virtual Studio Code will work, but needs Plugins to feel like an IDE.","title":"Which IDE is recommended?"},{"location":"06_faq/#which-programs-are-recommended","text":"Front end Operating Systems: macOs, Linux, Windows (mind the problems) IDEs : PyCharm Professional, Visual Studio Code Browser : Brave, Chrome, Firefox (Chromium-based Browsers with Vue.js Plugin) Misc: Docker, npm Back end Operating Systems: macOs, Linux, Windows (mind the problems) IDEs : PyCharm Professional, Visual Studio Code Programs: DBeaver Browser : Brave, Chrome, Firefox (Chromium-based Browsers with Vue.js Plugin) Misc: Docker","title":"Which programs are recommended?"},{"location":"06_faq/#what-are-the-programming-languagestechnologies-that-are-used","text":"Front end HTML, CSS, JS Vue.js Bootstrap JSON Back end Python Django PostgreSQL Shell Docker JSON","title":"What are the programming languages/technologies that are used?"},{"location":"06_faq/#localhost8000-is-not-showing-the-app","text":"You started Docker but localhost:8000 is not showing the App? There is a couple of things that could be wrong here. Front end is not up and running First of all, make sure, that the front end is being served. You can achieve this by running npm install once and then npm run serve inside the vue_frontend directory of the project. npm run serve will serve the front end and enable hot reloading, which means that all changes made to the code will automatically refresh the page in the browser after saving the file. Cache is broken The app is made to make as little requests as necessary. That means, if some JavaScript or CSS file that is needed for the page was already loaded into the cache once, the page will most likely not request the same file again unless the file is marked as modified. This is one reason, why the webpack configuration, that bundles the front end .vue files to static .js and .css files generates a unique hash that is appended to every file. The files will be renewed in the browser after every build process. In local development however, the development cycle might lead to a broken cache, i.e. a cache, where files are mistaken to be the newest when they aren't. The easiest way to verify if that is the problem you are encountering is to delete the cached files or to see if the problem persists in a private window. Personal experience showed, that these caching problems in local development rarely occur, when building the project with npm run build after a developing session. Serving in the wrong location The standard port of local development for Vue.js is :8080 whereas the Docker will serve on port :8000 . Both will work, but localhost:8000 is preferable and used throughout the application. Depending on your system/machine it is possible, that localhost or 0.0.0.0 or 127.0.0.1 is not the IP that your Docker instance is serving the app on. Another possibility is, that the ports are not available to your host system or blocked by the firewall. Vue.js will usually automatically turn to another port then but in cases might not. So for debugging, you might follow these steps: https://stackoverflow.com/questions/46176584/docker-bind-for-0-0-0-04000-failed-port-is-already-allocated Check your firewall settings for the ports Check the IP/Port of your docker process(es) When you encounter another IP than any of the localhost IPs, it is important to whitelist them in the django app ( ALLOWED_HOSTS ) and also to exchange all strings containing the localhost URL to your new IP. The ALLOWED_HOSTS can e.g. be altered in config/settings/local.py . More information on ALLOWED_HOSTS: https://docs.djangoproject.com/en/dev/ref/settings/#allowed-hosts","title":"localhost:8000 is not showing the app."},{"location":"06_faq/#ive-got-problems-with-docker-on-windows","text":"Windows is the least recommended Operation System. It seems to be well known, that there are problems when Hyper-V and VirtualBox coexist in a Windows installation. This could lead to problems if you e.g. use something like VirtualBox on your Windows machine and want to install/use Docker (using Hyper-V) as well. Further information on this: https://www.mt-ag.com/blog/ki-werkstatt/koexistenz-von-hyper-v-und-virtualbox-fur-den-einsatz-von-docker/","title":"I've got problems with Docker on Windows..."},{"location":"07_Resources/","text":"Resources Frameworks, Libraries & other Resources Django Background Tasks https://github.com/arteria/django-background-tasks Documentation of the Vue Argon Dashboard Template https://github.com/creativetimofficial/vue-argon-dashboard Django Postgres Documentation https://docs.djangoproject.com/en/3.1/ref/contrib/postgres/ Django Security Documentation https://docs.djangoproject.com/en/3.1/topics/security/ Django Documentation https://www.djangoproject.com/ Django Channels https://channels.readthedocs.io/en/stable/ Django Channel Layers https://channels.readthedocs.io/en/stable/topics/channel_layers.html Django REST Framework https://www.django-rest-framework.org/ WebSocket Protocol https://tools.ietf.org/html/rfc6455 Django Channels REST Framework Client https://github.com/theY4Kman/dcrf-client Redis https://redis.io/ PostgreSQL https://www.postgresql.org/ Vuex PersistedState https://github.com/robinvdvleuten/vuex-persistedstate Vue Router https://router.vuejs.org/ Vue.js https://vuejs.org/ Vuex https://vuex.vuejs.org/#what-is-a-state-management-pattern Django Channels REST Framework https://github.com/hishnash/djangochannelsrestframework WebPack https://webpack.js.org/","title":"Resources"},{"location":"07_Resources/#resources","text":"","title":"Resources"},{"location":"07_Resources/#frameworks-libraries-other-resources","text":"Django Background Tasks https://github.com/arteria/django-background-tasks Documentation of the Vue Argon Dashboard Template https://github.com/creativetimofficial/vue-argon-dashboard Django Postgres Documentation https://docs.djangoproject.com/en/3.1/ref/contrib/postgres/ Django Security Documentation https://docs.djangoproject.com/en/3.1/topics/security/ Django Documentation https://www.djangoproject.com/ Django Channels https://channels.readthedocs.io/en/stable/ Django Channel Layers https://channels.readthedocs.io/en/stable/topics/channel_layers.html Django REST Framework https://www.django-rest-framework.org/ WebSocket Protocol https://tools.ietf.org/html/rfc6455 Django Channels REST Framework Client https://github.com/theY4Kman/dcrf-client Redis https://redis.io/ PostgreSQL https://www.postgresql.org/ Vuex PersistedState https://github.com/robinvdvleuten/vuex-persistedstate Vue Router https://router.vuejs.org/ Vue.js https://vuejs.org/ Vuex https://vuex.vuejs.org/#what-is-a-state-management-pattern Django Channels REST Framework https://github.com/hishnash/djangochannelsrestframework WebPack https://webpack.js.org/","title":"Frameworks, Libraries &amp; other Resources"},{"location":"Changelog/","text":"Changelog Dengue Dashboard Docs v1.0.5 - September 2021 Add FAQs Add new front end tutorials v1.0.4 - June 20, 2021 Add info and sample images to index Add functions and structure description to front end Add functions and structure description to back end Restructure and add content to installation Add content to basics Add new page basics/back end Add new page basics/front end Add new page back end/api documentation Add new page back end/django admin Add new page front end/local development Add new page front end/production Restructure \"The System\" -> \"Deeper Dive\" v1.0.3 - June 16, 2021 Add crud tutorials v1.0.3 - June 13, 2021 Add back end consumer observer tutorial v1.0.3 - June 8, 2021 Add Tutorials/WebSocket Tutorial v1.0.3 - June 7, 2021 Restructuring the navigation Add Tutorials/REST API Tutorial v1.0.2 - June 6, 2021 Add content to Basics page: WebSockets, HTTP, Consumer, Components, Routing, State-management v1.0.2 - June 1, 2021 Add content to Back end page Start writing content for Front end page Add dark mode Basics: Add MVT diagram and System Overview Back end: Add \"Getting started\" explanations for folders Back end: Restructuring v1.0.1 - May 16, 2021 Modify Layout of Installation page and add Note Add content to Back end page (Structure) v1.0.0 - May 9, 2021 Create About page Create FAQ page Create Installation page Create Resources page Create Basics page Create Changelog page","title":"Changelog"},{"location":"Changelog/#changelog","text":"","title":"Changelog"},{"location":"Changelog/#dengue-dashboard-docs","text":"","title":"Dengue Dashboard Docs"},{"location":"Changelog/#v105-september-2021","text":"Add FAQs Add new front end tutorials","title":"v1.0.5 - September 2021"},{"location":"Changelog/#v104-june-20-2021","text":"Add info and sample images to index Add functions and structure description to front end Add functions and structure description to back end Restructure and add content to installation Add content to basics Add new page basics/back end Add new page basics/front end Add new page back end/api documentation Add new page back end/django admin Add new page front end/local development Add new page front end/production Restructure \"The System\" -> \"Deeper Dive\"","title":"v1.0.4 - June 20, 2021"},{"location":"Changelog/#v103-june-16-2021","text":"Add crud tutorials","title":"v1.0.3 - June 16, 2021"},{"location":"Changelog/#v103-june-13-2021","text":"Add back end consumer observer tutorial","title":"v1.0.3 - June 13, 2021"},{"location":"Changelog/#v103-june-8-2021","text":"Add Tutorials/WebSocket Tutorial","title":"v1.0.3 - June 8, 2021"},{"location":"Changelog/#v103-june-7-2021","text":"Restructuring the navigation Add Tutorials/REST API Tutorial","title":"v1.0.3 - June 7, 2021"},{"location":"Changelog/#v102-june-6-2021","text":"Add content to Basics page: WebSockets, HTTP, Consumer, Components, Routing, State-management","title":"v1.0.2 - June 6, 2021"},{"location":"Changelog/#v102-june-1-2021","text":"Add content to Back end page Start writing content for Front end page Add dark mode Basics: Add MVT diagram and System Overview Back end: Add \"Getting started\" explanations for folders Back end: Restructuring","title":"v1.0.2 - June 1, 2021"},{"location":"Changelog/#v101-may-16-2021","text":"Modify Layout of Installation page and add Note Add content to Back end page (Structure)","title":"v1.0.1 - May 16, 2021"},{"location":"Changelog/#v100-may-9-2021","text":"Create About page Create FAQ page Create Installation page Create Resources page Create Basics page Create Changelog page","title":"v1.0.0 - May 9, 2021"}]}